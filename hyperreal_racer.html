<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HyperRacer (Realistic-ish WebGL)</title>
  <style>
    :root{--fg:#eef2ff;--muted:#c7c8ff;--bg:#070b14}
    html,body{height:100%;margin:0;overflow:hidden;background:radial-gradient(1200px 900px at 50% 20%, #1a2a55, var(--bg) 65%);
      color:var(--fg);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header,footer{position:fixed;left:0;right:0;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;
      background:linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,0));border-bottom:1px solid rgba(255,255,255,.10)}
    footer{top:auto;bottom:0;border-bottom:none;border-top:1px solid rgba(255,255,255,.10);
      background:linear-gradient(to top, rgba(255,255,255,.08), rgba(255,255,255,0));color:var(--muted)}
    h1{margin:0;font-size:14px;letter-spacing:.12em;text-transform:uppercase}
    .sub{color:var(--muted);font-size:12px}
    .right{display:flex;gap:10px;align-items:center}
    .pill{border:1px solid rgba(255,255,255,.18);background:rgba(0,0,0,.22);backdrop-filter: blur(6px);
      border-radius:999px;padding:6px 10px;display:flex;gap:10px;align-items:center}
    .pill b{font-variant-numeric:tabular-nums}

    #panelWrap{position:fixed;inset:48px 0 46px 0;display:grid;place-items:center;pointer-events:none}
    .panel{pointer-events:auto;width:min(720px, calc(100% - 28px));border-radius:16px;border:1px solid rgba(255,255,255,.16);
      background:linear-gradient(180deg, rgba(0,0,0,.48), rgba(0,0,0,.22));box-shadow:0 30px 90px rgba(0,0,0,.55);
      backdrop-filter: blur(10px);padding:16px 16px 14px}
    .panel h2{margin:0 0 6px;font-size:14px;letter-spacing:.12em;text-transform:uppercase}
    .panel p{margin:0 0 12px;color:var(--muted)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    button{appearance:none;border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));color:var(--fg);
      border-radius:12px;padding:10px 12px;cursor:pointer;font-weight:750}
    button.secondary{background:rgba(0,0,0,.22);font-weight:650}
    button:active{transform:translateY(1px)}
    .hint{font-size:12px;color:rgba(232,236,255,.72)}
    kbd{font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;color:var(--fg);
      border:1px solid rgba(255,255,255,.22);background:rgba(0,0,0,.30);border-radius:6px;padding:2px 6px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>HyperRacer</h1>
      <div class="sub">“hyperrealistic-ish” • WebGL PBR materials • no external textures</div>
    </div>
    <div class="right">
      <div class="pill"><span>Speed</span><b id="spd">0</b></div>
      <div class="pill"><span>Distance</span><b id="dist">0.0</b></div>
      <div class="pill"><span>Time</span><b id="time">0.0</b></div>
    </div>
  </header>

  <div id="panelWrap">
    <div class="panel" id="menu">
      <h2>Start</h2>
      <p>This is a “more realistic” racer within the limits of a single-file demo: PBR shading, shadowed sun, fog, procedural road texture, and camera shake.
      Full hyperrealism would need large assets (HDR skyboxes, scanned textures, complex car models).</p>
      <div class="row">
        <button id="btnPlay">Drive</button>
        <button id="btnQuality" class="secondary">Quality: High</button>
      </div>
      <p class="hint">Controls: steer <kbd>A</kbd>/<kbd>D</kbd> or <kbd>←</kbd>/<kbd>→</kbd> • accelerate <kbd>W</kbd>/<kbd>↑</kbd> • brake <kbd>S</kbd>/<kbd>↓</kbd> • restart <kbd>R</kbd></p>
    </div>
  </div>

  <footer>
    <div>Steer <kbd>A</kbd>/<kbd>D</kbd> • Accelerate <kbd>W</kbd> • Brake <kbd>S</kbd> • Restart <kbd>R</kbd></div>
    <div id="status">Ready.</div>
  </footer>

  <script src="./three.min.js"></script>
  <script>
  (() => {
    const THREE = window.THREE;
    if(!THREE){ alert('three.min.js missing. Put three.min.js next to this HTML.'); return; }

    const ui = {
      spd: document.getElementById('spd'),
      dist: document.getElementById('dist'),
      time: document.getElementById('time'),
      status: document.getElementById('status'),
      menu: document.getElementById('menu'),
      btnPlay: document.getElementById('btnPlay'),
      btnQuality: document.getElementById('btnQuality')
    };

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;

    function hideMenu(){ ui.menu.style.display='none'; }

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setClearColor(0x000000, 0);
    renderer.physicallyCorrectLights = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1020, 0.018);

    const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 500);

    // Sky gradient (shader-ish via big sphere + vertex colors)
    const skyGeo = new THREE.SphereGeometry(300, 24, 16);
    skyGeo.scale(-1,1,1);
    const pos = skyGeo.attributes.position;
    const colors = [];
    const top = new THREE.Color(0x85b7ff);
    const mid = new THREE.Color(0x27407a);
    const bot = new THREE.Color(0x070b14);
    for(let i=0;i<pos.count;i++){
      const y = pos.getY(i);
      const t = clamp((y+300)/600, 0, 1);
      const c = new THREE.Color();
      if(t>0.55){ c.copy(mid).lerp(top, (t-0.55)/0.45); }
      else { c.copy(bot).lerp(mid, t/0.55); }
      colors.push(c.r,c.g,c.b);
    }
    skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    const sky = new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({ vertexColors:true }));
    scene.add(sky);

    // Lighting
    scene.add(new THREE.HemisphereLight(0xbfdcff, 0x1a0f26, 0.35));

    const sun = new THREE.DirectionalLight(0xffffff, 4.0);
    sun.position.set(-10, 14, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 2;
    sun.shadow.camera.far = 80;
    sun.shadow.camera.left = -24;
    sun.shadow.camera.right = 24;
    sun.shadow.camera.top = 24;
    sun.shadow.camera.bottom = -24;
    scene.add(sun);

    // World
    const world = new THREE.Group();
    scene.add(world);

    // Procedural road texture
    function makeRoadTexture(){
      const cv = document.createElement('canvas');
      cv.width = 1024;
      cv.height = 1024;
      const g = cv.getContext('2d');
      // asphalt base
      g.fillStyle = '#1b1f2a';
      g.fillRect(0,0,cv.width,cv.height);
      // noise
      const img = g.getImageData(0,0,cv.width,cv.height);
      const d = img.data;
      for(let i=0;i<d.length;i+=4){
        const n = (Math.random()*40)|0;
        d[i]+=n; d[i+1]+=n; d[i+2]+=n;
      }
      g.putImageData(img,0,0);
      // lane lines
      g.strokeStyle = 'rgba(255,255,255,0.85)';
      g.lineWidth = 18;
      g.setLineDash([60, 48]);
      g.beginPath();
      g.moveTo(cv.width*0.5, 0);
      g.lineTo(cv.width*0.5, cv.height);
      g.stroke();
      // edge lines
      g.setLineDash([]);
      g.strokeStyle = 'rgba(255,214,107,0.75)';
      g.lineWidth = 10;
      g.beginPath();
      g.moveTo(cv.width*0.12, 0); g.lineTo(cv.width*0.12, cv.height);
      g.moveTo(cv.width*0.88, 0); g.lineTo(cv.width*0.88, cv.height);
      g.stroke();
      const tex = new THREE.CanvasTexture(cv);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(1, 10);
      tex.anisotropy = 8;
      return tex;
    }

    const roadTex = makeRoadTexture();
    const roadMat = new THREE.MeshStandardMaterial({
      map: roadTex,
      roughness: 0.92,
      metalness: 0.02
    });

    const road = new THREE.Mesh(new THREE.PlaneGeometry(14, 240, 1, 1), roadMat);
    road.rotation.x = -Math.PI/2;
    road.receiveShadow = true;
    world.add(road);

    // Side ground
    const grassMat = new THREE.MeshStandardMaterial({ color: 0x0a1720, roughness: 1.0, metalness: 0.0 });
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 240), grassMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.02;
    ground.receiveShadow = true;
    world.add(ground);

    // Simple roadside props (trees)
    const treeMat = new THREE.MeshStandardMaterial({ color: 0x0b2a1a, roughness: 1.0 });
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3a2b1a, roughness: 1.0 });
    const props = new THREE.Group();
    world.add(props);
    function addTree(x,z, s=1){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.22, 1.4, 8), trunkMat);
      trunk.position.y = 0.7;
      trunk.castShadow = true;
      const crown = new THREE.Mesh(new THREE.ConeGeometry(0.9, 2.2, 10), treeMat);
      crown.position.y = 2.1;
      crown.castShadow = true;
      g.add(trunk, crown);
      g.position.set(x,0,z);
      g.scale.setScalar(s);
      props.add(g);
      return g;
    }
    const trees=[];
    for(let i=0;i<60;i++){
      const side = i%2===0 ? -1 : 1;
      const x = side*(8 + Math.random()*18);
      const z = -10 - Math.random()*220;
      trees.push(addTree(x,z, 0.9+Math.random()*0.8));
    }

    // Car
    const car = new THREE.Group();
    world.add(car);

    const paint = new THREE.MeshPhysicalMaterial({
      color: 0x9d0cff,
      roughness: 0.25,
      metalness: 0.75,
      clearcoat: 1.0,
      clearcoatRoughness: 0.08
    });

    const carBody = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.55, 4.2), paint);
    carBody.position.y = 0.55;
    carBody.castShadow = true;
    car.add(carBody);

    const carCab = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1.6), new THREE.MeshPhysicalMaterial({
      color: 0xbfe8ff,
      roughness: 0.05,
      metalness: 0.0,
      transmission: 0.9,
      thickness: 0.9,
      transparent: true,
      opacity: 0.85
    }));
    carCab.position.set(0, 0.98, -0.3);
    carCab.castShadow = true;
    car.add(carCab);

    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x0b0b0e, roughness: 0.95, metalness: 0.05 });
    const wheelGeo = new THREE.CylinderGeometry(0.34,0.34,0.26, 18);
    function wheel(x,z){
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z = Math.PI/2;
      w.position.set(x, 0.34, z);
      w.castShadow = true;
      car.add(w);
      return w;
    }
    const wheels=[wheel(-0.95,1.4), wheel(0.95,1.4), wheel(-0.95,-1.4), wheel(0.95,-1.4)];

    // Player state
    const state = {
      running:false,
      quality:'high',
      t:0,
      last:performance.now(),
      speed:0,
      dist:0,
      x:0
    };

    const input = { left:false,right:false,up:false,down:false };
    addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if(['a','arrowleft'].includes(k)) input.left=true;
      if(['d','arrowright'].includes(k)) input.right=true;
      if(['w','arrowup'].includes(k)) input.up=true;
      if(['s','arrowdown'].includes(k)) input.down=true;
      if(k==='r') restart();
    });
    addEventListener('keyup', (e)=>{
      const k = e.key.toLowerCase();
      if(['a','arrowleft'].includes(k)) input.left=false;
      if(['d','arrowright'].includes(k)) input.right=false;
      if(['w','arrowup'].includes(k)) input.up=false;
      if(['s','arrowdown'].includes(k)) input.down=false;
    });

    function resize(){
      const w=innerWidth,h=innerHeight;
      camera.aspect=w/h;
      camera.updateProjectionMatrix();
      const dpr=devicePixelRatio||1;
      renderer.setPixelRatio(state.quality==='high'?Math.min(2,dpr):1);
      renderer.setSize(w,h,false);
    }
    addEventListener('resize', resize);

    function restart(){
      state.running=true;
      state.t=0;
      state.last=performance.now();
      state.speed=0;
      state.dist=0;
      state.x=0;
      car.position.set(0,0, 10);
      roadTex.offset.y = 0;
      ui.status.textContent='Drive.';
      hideMenu();
    }

    ui.btnPlay.onclick = restart;
    ui.btnQuality.onclick = () => {
      state.quality = state.quality==='high' ? 'low' : 'high';
      ui.btnQuality.textContent = `Quality: ${state.quality==='high'?'High':'Low'}`;
      ui.status.textContent = state.quality==='high' ? 'High quality.' : 'Low quality.';
      resize();
    };

    // Camera
    camera.position.set(0, 4.2, 15.5);
    camera.lookAt(0, 1.0, 0);

    function tick(now){
      requestAnimationFrame(tick);
      if(!renderer.domElement.width) resize();

      if(!state.running){
        // idle
        car.rotation.y = Math.sin(performance.now()*0.001)*0.04;
        renderer.render(scene, camera);
        return;
      }

      const dt = Math.min(0.033, (now-state.last)/1000);
      state.last=now;
      state.t += dt;

      const maxSpeed=65;
      const accel=38;
      const brake=55;
      const drag=7.5;

      if(input.up) state.speed += accel*dt;
      if(input.down) state.speed -= brake*dt;
      state.speed = lerp(state.speed, 0, drag*dt);
      state.speed = clamp(state.speed, 0, maxSpeed);

      const steer = (input.right?1:0) - (input.left?1:0);
      state.x += steer * (6.0 + state.speed*0.06) * dt;
      state.x = clamp(state.x, -4.2, 4.2);

      car.position.x = lerp(car.position.x, state.x, 6*dt);
      car.rotation.z = lerp(car.rotation.z, -steer*0.14, 6*dt);
      car.rotation.y = lerp(car.rotation.y, -steer*0.06, 4*dt);
      for(const w of wheels) w.rotation.x += state.speed*dt*0.35;

      // scroll road texture
      roadTex.offset.y -= state.speed*dt*0.02;

      // move scenery toward camera
      const dz = state.speed*dt;
      state.dist += dz*0.06;
      ui.dist.textContent = state.dist.toFixed(1);
      ui.time.textContent = state.t.toFixed(1);
      ui.spd.textContent = String(Math.round(state.speed*3.6));

      for(const tr of trees){
        tr.position.z += dz;
        if(tr.position.z > 18){
          tr.position.z = -220 - Math.random()*120;
          const side = tr.position.x<0 ? -1 : 1;
          tr.position.x = side*(8 + Math.random()*18);
        }
      }

      // camera follow with subtle shake
      const shake = (state.speed/maxSpeed) * 0.10;
      camera.position.x = lerp(camera.position.x, car.position.x*0.25, 4.8*dt) + Math.sin(state.t*16)*shake;
      camera.position.y = lerp(camera.position.y, 4.2, 2.6*dt);
      camera.position.z = lerp(camera.position.z, 15.5, 2.6*dt);
      camera.lookAt(car.position.x*0.15, 1.0, car.position.z-8);

      renderer.render(scene, camera);
    }

    resize();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
