<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Strongest Battlegrounds Remix</title>
  <style>
    :root{
      --bg:#070815;
      --panel:#0e1030;
      --panel2:#12144a;
      --text:#e9ecff;
      --muted:#aab0ff;
      --good:#6dffb0;
      --bad:#ff5f7f;
      --warn:#ffd36d;
      --accent:#7aa6ff;
      --line:rgba(255,255,255,.12);
      --shadow: 0 14px 40px rgba(0,0,0,.55);
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 70% 20%, #151a60 0%, var(--bg) 55%, #050512 100%);color:var(--text);font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
    a{color:var(--muted);text-decoration:none}
    a:hover{text-decoration:underline}

    .wrap{max-width:980px;margin:0 auto;padding:18px 16px 28px;}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;}
    .back{display:inline-flex;align-items:center;gap:10px;padding:10px 12px;border:1px solid var(--line);border-radius:12px;background:rgba(0,0,0,.18)}
    .back strong{color:var(--text);font-weight:650}
    .pill{font-size:12px;color:var(--muted);border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:rgba(0,0,0,.14)}

    .grid{display:grid;grid-template-columns: 1.35fr .65fr;gap:14px;}
    @media (max-width: 920px){.grid{grid-template-columns: 1fr;}}

    .card{background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));border:1px solid var(--line);border-radius:18px;box-shadow:var(--shadow);overflow:hidden;}
    .card .hd{padding:14px 16px;border-bottom:1px solid var(--line);display:flex;align-items:flex-start;justify-content:space-between;gap:10px}
    .title{font-weight:800;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:13px;margin-top:4px;line-height:1.35}
    .rightcol .card{position:sticky;top:14px}
    @media (max-width: 920px){.rightcol .card{position:static;}}

    .canvasWrap{background:radial-gradient(800px 500px at 50% 30%, rgba(122,166,255,.22) 0%, rgba(0,0,0,.18) 55%, rgba(0,0,0,.35) 100%);
      display:flex;align-items:center;justify-content:center;padding:10px;}

    canvas{width:min(100%, 720px);height:auto;aspect-ratio: 16/10;max-height: 520px;border-radius:16px;border:1px solid rgba(255,255,255,.14);background: #050616;}

    .panel{padding:14px 16px;}
    .kv{display:grid;grid-template-columns: 1fr auto;gap:10px;align-items:center;margin:10px 0;}
    .k{color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.12em}
    .v{font-variant-numeric: tabular-nums; font-weight:800;}

    .btnrow{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    button{
      cursor:pointer;border:1px solid rgba(255,255,255,.16);
      background:linear-gradient(180deg, rgba(122,166,255,.22), rgba(122,166,255,.10));
      color:var(--text);padding:10px 12px;border-radius:12px;font-weight:750;
      box-shadow: 0 10px 18px rgba(0,0,0,.35);
    }
    button:hover{filter:brightness(1.06)}
    button:active{transform:translateY(1px)}
    .ghost{background:rgba(0,0,0,.18)}

    .help{color:var(--muted);font-size:13px;line-height:1.45}
    .keys{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .key{font-size:12px;color:var(--text);border:1px solid var(--line);border-radius:10px;padding:5px 8px;background:rgba(0,0,0,.18)}

    .footerNote{margin-top:10px;color:var(--muted);font-size:12px}
    .warn{color:var(--warn)}
    .good{color:var(--good)}
    .bad{color:var(--bad)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <a class="back" href="./index.html" aria-label="Back to Claw Games">
        <span aria-hidden="true">‚Üê</span>
        <strong>Back to Claw Games</strong>
      </a>
      <div class="pill">Single-file microgame</div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="hd">
          <div>
            <div class="title">Strongest Battlegrounds Remix</div>
            <div class="sub">Arena duels in 90 seconds. Build <b>Focus</b>, land <b>Combos</b>, and survive the <b>Storm Ring</b>.</div>
          </div>
          <div class="pill">Inspired by The Strongest Battlegrounds</div>
        </div>
        <div class="canvasWrap">
          <canvas id="c" width="960" height="600" aria-label="Game canvas"></canvas>
        </div>
      </div>

      <div class="rightcol">
        <div class="card">
          <div class="hd">
            <div>
              <div class="title">Status</div>
              <div class="sub" id="statusSub">Press <b>Enter</b> to begin.</div>
            </div>
            <div class="pill" id="modePill">Title</div>
          </div>
          <div class="panel">
            <div class="kv"><div class="k">Score</div><div class="v" id="score">0</div></div>
            <div class="kv"><div class="k">Time</div><div class="v" id="time">90.0</div></div>
            <div class="kv"><div class="k">HP</div><div class="v" id="hp">100</div></div>
            <div class="kv"><div class="k">Focus</div><div class="v" id="focus">0</div></div>
            <div class="kv"><div class="k">Combo</div><div class="v" id="combo">x1</div></div>

            <div class="btnrow">
              <button id="btnStart">Start</button>
              <button id="btnRestart" class="ghost">Restart</button>
              <button id="btnMute" class="ghost">Sound: On</button>
            </div>

            <div class="help" style="margin-top:12px">
              <div><b>Goal:</b> reach <span class="good"><b>1200</b></span> score before time runs out.</div>
              <div style="margin-top:8px"><b>Lose if:</b> HP hits <span class="bad"><b>0</b></span>.</div>
              <div style="margin-top:8px"><b>Controls</b></div>
              <div class="keys">
                <span class="key">WASD / Arrows</span>
                <span class="key">Space = Dash</span>
                <span class="key">J = Jab</span>
                <span class="key">K = Kick</span>
                <span class="key">L = Burst (Focus)</span>
                <span class="key">Enter = Start</span>
              </div>
              <div class="footerNote">Tip: alternate <b>J</b> and <b>K</b> quickly to build combo. Stay inside the <b class="warn">Storm Ring</b>!</div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    score: document.getElementById('score'),
    time: document.getElementById('time'),
    hp: document.getElementById('hp'),
    focus: document.getElementById('focus'),
    combo: document.getElementById('combo'),
    statusSub: document.getElementById('statusSub'),
    modePill: document.getElementById('modePill'),
    btnStart: document.getElementById('btnStart'),
    btnRestart: document.getElementById('btnRestart'),
    btnMute: document.getElementById('btnMute')
  };

  // ---------- tiny audio (no external assets) ----------
  let audioOn = true;
  let ac = null;
  function ensureAudio(){
    if (!audioOn) return null;
    if (!ac){
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return null;
      ac = new AudioCtx();
    }
    if (ac.state === 'suspended') ac.resume().catch(()=>{});
    return ac;
  }
  function beep(type='sine', freq=440, dur=0.06, gain=0.06){
    const a = ensureAudio();
    if (!a) return;
    const o = a.createOscillator();
    const g = a.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(a.destination);
    const t = a.currentTime;
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.start(t);
    o.stop(t + dur);
  }
  function thump(){ beep('triangle', 92, 0.09, 0.08); }
  function tick(){ beep('square', 690, 0.035, 0.04); }
  function whoosh(){ beep('sawtooth', 220, 0.07, 0.05); }

  // ---------- math/helpers ----------
  const TAU = Math.PI * 2;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const len = (x, y) => Math.hypot(x, y);

  function rnd(min, max){ return min + Math.random() * (max - min); }

  // ---------- input ----------
  const keys = new Set();
  const pressed = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (!keys.has(k)) pressed.add(k);
    keys.add(k);
    if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key)) e.preventDefault();
    if (k === 'enter') e.preventDefault();
  }, {passive:false});
  window.addEventListener('keyup', (e) => {
    keys.delete(e.key.toLowerCase());
  });

  // ---------- game state ----------
  const W = canvas.width, H = canvas.height;

  const state = {
    mode: 'title', // title | playing | win | lose
    t: 0,
    dt: 0,
    timeLeft: 90,
    score: 0,
    goal: 1200,
    combo: 1,
    comboTimer: 0,
    focus: 0,
    focusMax: 100,
    storm: {
      cx: W * 0.52,
      cy: H * 0.52,
      r: 260,
      targetR: 260,
      pulse: 0
    },
    shake: 0,
    floatingText: []
  };

  const player = {
    x: W * 0.33,
    y: H * 0.55,
    vx: 0,
    vy: 0,
    r: 15,
    hp: 100,
    dashCd: 0,
    dashInvuln: 0,
    facing: 0,
    lastAttack: '',
    attackCd: 0,
    attackArc: 0,
    trail: []
  };

  const bots = [];
  const particles = [];

  function reset(){
    state.mode = 'title';
    state.t = 0;
    state.timeLeft = 90;
    state.score = 0;
    state.combo = 1;
    state.comboTimer = 0;
    state.focus = 0;
    state.storm.r = 270;
    state.storm.targetR = 270;
    state.storm.pulse = 0;
    state.shake = 0;
    state.floatingText.length = 0;

    player.x = W * 0.33;
    player.y = H * 0.55;
    player.vx = player.vy = 0;
    player.hp = 100;
    player.dashCd = 0;
    player.dashInvuln = 0;
    player.facing = 0;
    player.lastAttack = '';
    player.attackCd = 0;
    player.attackArc = 0;
    player.trail.length = 0;

    bots.length = 0;
    particles.length = 0;

    spawnBotWave(3);
    syncUI();
  }

  function setMode(mode){
    state.mode = mode;
    ui.modePill.textContent = mode[0].toUpperCase() + mode.slice(1);
    if (mode === 'title') ui.statusSub.innerHTML = 'Press <b>Enter</b> to begin.';
    if (mode === 'playing') ui.statusSub.textContent = 'Fight smart: combo for points, burst to clear space.';
    if (mode === 'win') ui.statusSub.innerHTML = 'You reached the goal! Press <b>Restart</b> or <b>Enter</b>.';
    if (mode === 'lose') ui.statusSub.innerHTML = 'Downed. Press <b>Restart</b> or <b>Enter</b>.';
  }

  function syncUI(){
    ui.score.textContent = Math.floor(state.score).toString();
    ui.time.textContent = state.timeLeft.toFixed(1);
    ui.hp.textContent = Math.max(0, Math.ceil(player.hp)).toString();
    ui.focus.textContent = Math.floor(state.focus).toString();
    ui.combo.textContent = 'x' + state.combo;
  }

  function addFloat(text, x, y, color){
    state.floatingText.push({text, x, y, vy: -22, life: 0.9, color});
  }

  function burstParticles(x,y, n=18, hue=210){
    for (let i=0;i<n;i++){
      const a = rnd(0, TAU);
      const sp = rnd(80, 360);
      particles.push({
        x, y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        r: rnd(1.5, 4.2),
        life: rnd(0.25, 0.7),
        hue,
        k: rnd(0.8, 1.3)
      });
    }
  }

  function spawnBotWave(count){
    for (let i=0;i<count;i++){
      const a = rnd(0, TAU);
      const d = rnd(state.storm.r * 0.35, state.storm.r * 0.85);
      const x = clamp(state.storm.cx + Math.cos(a)*d, 60, W-60);
      const y = clamp(state.storm.cy + Math.sin(a)*d, 60, H-60);
      bots.push({
        x, y,
        vx: 0,
        vy: 0,
        r: rnd(13, 18),
        hp: 26,
        maxHp: 26,
        wob: rnd(0, 10),
        intent: rnd(0, TAU),
        hitFlash: 0,
        biteCd: rnd(0.4, 1.2)
      });
    }
  }

  function damagePlayer(amount, knockX=0, knockY=0){
    if (player.dashInvuln > 0) return;
    player.hp -= amount;
    player.vx += knockX;
    player.vy += knockY;
    state.shake = Math.min(10, state.shake + 6);
    burstParticles(player.x, player.y, 14, 340);
    beep('square', 140, 0.06, 0.07);
    if (player.hp <= 0) {
      player.hp = 0;
      setMode('lose');
      thump();
    }
  }

  function scoreHit(base, x, y){
    const add = base * state.combo;
    state.score += add;
    state.focus = clamp(state.focus + base * 1.6, 0, state.focusMax);
    addFloat('+' + Math.floor(add), x, y, 'rgba(109,255,176,.95)');
  }

  function bumpCombo(){
    state.comboTimer = 1.1;
    state.combo = clamp(state.combo + 1, 1, 10);
  }

  function decayCombo(dt){
    state.comboTimer -= dt;
    if (state.comboTimer <= 0){
      state.comboTimer = 0;
      state.combo = lerp(state.combo, 1, 1 - Math.exp(-dt*6));
      state.combo = Math.max(1, state.combo);
    }
  }

  function doAttack(kind){
    if (state.mode !== 'playing') return;
    if (player.attackCd > 0) return;

    // Alternate attacks for best combo.
    const sameAsLast = (player.lastAttack === kind);
    const baseCd = kind === 'jab' ? 0.16 : 0.24;
    player.attackCd = baseCd;
    player.lastAttack = kind;

    const arc = kind === 'jab' ? 0.75 : 1.1;
    const range = kind === 'jab' ? 56 : 72;
    const dmg = kind === 'jab' ? 9 : 13;
    const baseScore = kind === 'jab' ? 18 : 28;

    // Small penalty if spamming same move.
    const eff = sameAsLast ? 0.75 : 1.0;

    // Visual swipe
    player.attackArc = arc;

    // Sound
    tick();

    let hitAny = false;
    for (const b of bots){
      if (b.hp <= 0) continue;
      const dx = b.x - player.x;
      const dy = b.y - player.y;
      const d = Math.hypot(dx, dy);
      if (d > range + b.r) continue;

      const ang = Math.atan2(dy, dx);
      const da = angleDiff(ang, player.facing);
      if (Math.abs(da) > arc) continue;

      // hit
      hitAny = true;
      const dealt = dmg * eff;
      b.hp -= dealt;
      b.hitFlash = 0.12;
      const kx = Math.cos(ang) * (kind === 'jab' ? 160 : 240);
      const ky = Math.sin(ang) * (kind === 'jab' ? 160 : 240);
      b.vx += kx;
      b.vy += ky;
      burstParticles(b.x, b.y, 10, 200);
      scoreHit(baseScore, b.x, b.y);
      bumpCombo();

      if (b.hp <= 0){
        b.hp = 0;
        burstParticles(b.x, b.y, 24, 265);
        addFloat('KO', b.x, b.y, 'rgba(122,166,255,.95)');
        state.score += 40 * state.combo;
        state.focus = clamp(state.focus + 22, 0, state.focusMax);
        state.shake = Math.min(12, state.shake + 5);
        beep('triangle', 520, 0.08, 0.07);
      }
    }

    if (!hitAny){
      // whiff: combo decays a bit
      state.comboTimer = Math.min(state.comboTimer, 0.55);
    }
  }

  function angleDiff(a, b){
    let d = a - b;
    while (d > Math.PI) d -= TAU;
    while (d < -Math.PI) d += TAU;
    return d;
  }

  function doBurst(){
    if (state.mode !== 'playing') return;
    if (state.focus < state.focusMax) {
      addFloat('Need Focus!', player.x, player.y-18, 'rgba(255,211,109,.95)');
      beep('sine', 240, 0.06, 0.05);
      return;
    }
    state.focus = 0;
    state.comboTimer = 1.2;
    state.combo = clamp(state.combo + 2, 1, 10);

    // Push bots away + score
    whoosh();
    burstParticles(player.x, player.y, 30, 165);
    state.shake = Math.min(14, state.shake + 7);

    for (const b of bots){
      if (b.hp <= 0) continue;
      const dx = b.x - player.x;
      const dy = b.y - player.y;
      const d = Math.hypot(dx, dy);
      const within = d < 150 + b.r;
      if (!within) continue;
      const ang = Math.atan2(dy, dx);
      const force = lerp(520, 260, clamp(d/150, 0, 1));
      b.vx += Math.cos(ang) * force;
      b.vy += Math.sin(ang) * force;
      b.hp -= 10;
      b.hitFlash = 0.18;
      scoreHit(34, b.x, b.y);
      if (b.hp <= 0){
        b.hp = 0;
        addFloat('KO', b.x, b.y, 'rgba(122,166,255,.95)');
        state.score += 60 * state.combo;
      }
    }
    addFloat('BURST!', player.x, player.y-24, 'rgba(109,255,176,.95)');
  }

  function dash(){
    if (state.mode !== 'playing') return;
    if (player.dashCd > 0) return;
    const ax = (keys.has('a')||keys.has('arrowleft')?-1:0) + (keys.has('d')||keys.has('arrowright')?1:0);
    const ay = (keys.has('w')||keys.has('arrowup')?-1:0) + (keys.has('s')||keys.has('arrowdown')?1:0);
    const m = Math.hypot(ax, ay);
    let dx = Math.cos(player.facing), dy = Math.sin(player.facing);
    if (m > 0.001){ dx = ax/m; dy = ay/m; }

    player.vx += dx * 720;
    player.vy += dy * 720;
    player.dashCd = 0.75;
    player.dashInvuln = 0.18;

    state.focus = clamp(state.focus + 8, 0, state.focusMax);

    for (let i=0;i<10;i++){
      player.trail.push({x: player.x - dx*i*4, y: player.y - dy*i*4, life: 0.25});
    }
    whoosh();
  }

  function startGame(){
    reset();
    setMode('playing');
    state.mode = 'playing';
    // subtle first instruction pop
    addFloat('Stay in the Storm Ring', state.storm.cx, state.storm.cy - state.storm.r - 10, 'rgba(255,211,109,.95)');
  }

  // ---------- update loop ----------
  let last = performance.now();
  function frame(now){
    const rawDt = (now - last) / 1000;
    last = now;
    const dt = clamp(rawDt, 0, 0.033);
    state.t += dt;

    // one-frame press
    const press = (k) => pressed.has(k);

    // global controls
    if (press('enter')){
      if (state.mode === 'playing') {
        // no-op
      } else {
        startGame();
      }
    }

    if (state.mode === 'playing'){
      updatePlaying(dt);

      if (press('j')) doAttack('jab');
      if (press('k')) doAttack('kick');
      if (press('l')) doBurst();
      if (press(' ')) dash();

      // win check
      if (state.score >= state.goal){
        setMode('win');
        beep('triangle', 660, 0.09, 0.07);
        beep('triangle', 880, 0.09, 0.07);
      }
    }

    // allow restart on end screens
    if ((state.mode === 'win' || state.mode === 'lose') && (press('enter'))){
      startGame();
    }

    render();
    syncUI();

    pressed.clear();
    requestAnimationFrame(frame);
  }

  function updatePlaying(dt){
    state.timeLeft -= dt;
    if (state.timeLeft <= 0){
      state.timeLeft = 0;
      if (state.score >= state.goal) {
        setMode('win');
      } else {
        setMode('lose');
      }
      thump();
    }

    // Storm shrinks in phases
    const t = 90 - state.timeLeft;
    // every ~15s, shrink target a bit
    const phase = Math.floor(t / 15);
    const base = 280;
    const minR = 170;
    state.storm.targetR = clamp(base - phase * 18, minR, base);
    state.storm.r = lerp(state.storm.r, state.storm.targetR, 1 - Math.exp(-dt*2.2));

    // ring drifts slightly
    const drift = 0.55;
    state.storm.cx = clamp(state.storm.cx + Math.cos(state.t*0.23)*drift, W*0.35, W*0.65);
    state.storm.cy = clamp(state.storm.cy + Math.sin(state.t*0.19)*drift, H*0.35, H*0.65);
    state.storm.pulse += dt;

    // Movement
    let ax = 0, ay = 0;
    if (keys.has('a') || keys.has('arrowleft')) ax -= 1;
    if (keys.has('d') || keys.has('arrowright')) ax += 1;
    if (keys.has('w') || keys.has('arrowup')) ay -= 1;
    if (keys.has('s') || keys.has('arrowdown')) ay += 1;

    const mag = Math.hypot(ax, ay);
    if (mag > 0.001){
      ax /= mag; ay /= mag;
      player.facing = Math.atan2(ay, ax);
    }

    const speed = 420;
    player.vx += ax * speed * dt;
    player.vy += ay * speed * dt;

    // Friction
    const fr = 1 - Math.exp(-dt*7.6);
    player.vx = lerp(player.vx, 0, fr);
    player.vy = lerp(player.vy, 0, fr);

    // integrate
    player.x += player.vx * dt;
    player.y += player.vy * dt;
    player.x = clamp(player.x, 30, W-30);
    player.y = clamp(player.y, 30, H-30);

    // cooldowns
    player.dashCd = Math.max(0, player.dashCd - dt);
    player.dashInvuln = Math.max(0, player.dashInvuln - dt);
    player.attackCd = Math.max(0, player.attackCd - dt);
    player.attackArc = lerp(player.attackArc, 0, 1 - Math.exp(-dt*10));

    // trail
    for (const t of player.trail){ t.life -= dt; }
    while (player.trail.length && player.trail[0].life <= 0) player.trail.shift();

    // combo/focus
    decayCombo(dt);
    state.focus = clamp(state.focus + dt*4.2, 0, state.focusMax); // slow passive regen

    // bots
    updateBots(dt);

    // storm damage
    const dx = player.x - state.storm.cx;
    const dy = player.y - state.storm.cy;
    const dist = Math.hypot(dx, dy);
    if (dist > state.storm.r){
      // damage increases as ring shrinks
      const severity = clamp((dist - state.storm.r) / 90, 0, 1);
      const dmg = (8 + (280 - state.storm.r) * 0.06) * (0.35 + severity);
      damagePlayer(dmg * dt, (dx/dist||0) * 22 * dt, (dy/dist||0) * 22 * dt);
      state.score = Math.max(0, state.score - 10 * dt);
    }

    // particles
    for (const p of particles){
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.06, dt);
      p.vy *= Math.pow(0.06, dt);
      p.r *= Math.pow(0.2, dt);
    }
    for (let i=particles.length-1;i>=0;i--) if (particles[i].life <= 0 || particles[i].r < 0.2) particles.splice(i,1);

    // floating text
    for (const ft of state.floatingText){
      ft.life -= dt;
      ft.y += ft.vy * dt;
      ft.vy -= 18 * dt;
    }
    for (let i=state.floatingText.length-1;i>=0;i--) if (state.floatingText[i].life <= 0) state.floatingText.splice(i,1);

    // spawn logic: keep pressure
    const living = bots.filter(b => b.hp > 0).length;
    // spawn more as time passes
    const desired = 3 + Math.floor((90 - state.timeLeft) / 20);
    if (living < desired){
      spawnBotWave(1);
    }

    // mild score drip for surviving
    state.score += dt * 2.2;
  }

  function updateBots(dt){
    for (const b of bots){
      if (b.hp <= 0) continue;
      b.wob += dt;
      b.hitFlash = Math.max(0, b.hitFlash - dt);
      b.biteCd -= dt;

      // move behavior: orbit + occasionally lunge
      const toPx = player.x - b.x;
      const toPy = player.y - b.y;
      const d = Math.hypot(toPx, toPy);

      // keep inside ring (bots also fear storm)
      const toCx = state.storm.cx - b.x;
      const toCy = state.storm.cy - b.y;
      const dc = Math.hypot(toCx, toCy);
      const stormPull = dc > state.storm.r*0.95 ? 1 : 0;

      let desireX = 0, desireY = 0;

      // orbit direction flips occasionally
      if ((Math.sin(b.wob*0.7) > 0.95) && Math.random() < 0.06) b.intent = rnd(0, TAU);
      const orbit = (Math.sin(b.wob*1.1) > 0 ? 1 : -1);

      // Approach until mid-range
      const target = 120;
      const approach = clamp((d - target) / 220, -1, 1);
      const nx = toPx / (d || 1);
      const ny = toPy / (d || 1);
      desireX += nx * approach;
      desireY += ny * approach;

      // orbit component
      desireX += -ny * orbit * 0.55;
      desireY += nx * orbit * 0.55;

      // storm pull
      if (stormPull){
        desireX += (toCx/(dc||1)) * 1.2;
        desireY += (toCy/(dc||1)) * 1.2;
      }

      // small randomness
      desireX += Math.cos(b.intent) * 0.10;
      desireY += Math.sin(b.intent) * 0.10;

      const m = Math.hypot(desireX, desireY) || 1;
      desireX /= m; desireY /= m;

      const sp = 240 + (1 - b.hp/b.maxHp) * 110;
      b.vx += desireX * sp * dt;
      b.vy += desireY * sp * dt;

      // friction
      const fr = 1 - Math.exp(-dt*6.5);
      b.vx = lerp(b.vx, 0, fr);
      b.vy = lerp(b.vy, 0, fr);

      // integrate
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.x = clamp(b.x, 28, W-28);
      b.y = clamp(b.y, 28, H-28);

      // bite
      const biteRange = b.r + player.r + 6;
      if (d < biteRange && b.biteCd <= 0){
        b.biteCd = rnd(0.55, 0.95);
        const ang = Math.atan2(toPy, toPx);
        damagePlayer(9 + (280 - state.storm.r)*0.02, Math.cos(ang)*120, Math.sin(ang)*120);
        addFloat('-HP', player.x, player.y-20, 'rgba(255,95,127,.95)');
      }

      // player collision bump (gentle)
      const ddx = b.x - player.x;
      const ddy = b.y - player.y;
      const dd = Math.hypot(ddx, ddy);
      const overlap = (b.r + player.r) - dd;
      if (overlap > 0){
        const nx2 = ddx/(dd||1);
        const ny2 = ddy/(dd||1);
        b.x += nx2 * overlap * 0.55;
        b.y += ny2 * overlap * 0.55;
        player.x -= nx2 * overlap * 0.45;
        player.y -= ny2 * overlap * 0.45;
      }
    }
  }

  // ---------- render ----------
  function render(){
    const shake = state.shake;
    state.shake = Math.max(0, state.shake - 0.8);
    const sx = (Math.random() - 0.5) * shake;
    const sy = (Math.random() - 0.5) * shake;

    ctx.save();
    ctx.clearRect(0,0,W,H);
    ctx.translate(sx, sy);

    // background grid
    drawBackground();

    // storm ring
    drawStorm();

    // particles under
    drawParticles();

    // bots
    for (const b of bots){
      if (b.hp <= 0) continue;
      drawBot(b);
    }

    // player trail
    drawTrail();

    // player
    drawPlayer();

    // swipe arc
    if (player.attackArc > 0.02) drawSwipe();

    // floating text
    drawFloatingText();

    // overlays
    if (state.mode !== 'playing') drawOverlay();

    ctx.restore();
  }

  function drawBackground(){
    // vignette
    const g = ctx.createRadialGradient(W*0.5, H*0.45, 50, W*0.5, H*0.5, 720);
    g.addColorStop(0, 'rgba(122,166,255,.12)');
    g.addColorStop(0.6, 'rgba(0,0,0,.25)');
    g.addColorStop(1, 'rgba(0,0,0,.55)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // subtle grid
    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.strokeStyle = 'rgba(255,255,255,.10)';
    ctx.lineWidth = 1;
    const step = 48;
    for (let x=0; x<=W; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for (let y=0; y<=H; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.restore();

    // corners
    ctx.save();
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = 'rgba(255,255,255,.05)';
    roundRect(18, 18, W-36, H-36, 18);
    ctx.fill();
    ctx.restore();
  }

  function drawStorm(){
    const {cx, cy, r} = state.storm;
    const pulse = (Math.sin(state.storm.pulse*2.4)+1)*0.5;

    // safe zone fill
    const inner = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r);
    inner.addColorStop(0, 'rgba(109,255,176,.06)');
    inner.addColorStop(1, 'rgba(109,255,176,.00)');
    ctx.fillStyle = inner;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, TAU);
    ctx.fill();

    // ring stroke
    ctx.save();
    ctx.lineWidth = 7;
    ctx.strokeStyle = `rgba(255,211,109,${0.35 + pulse*0.18})`;
    ctx.setLineDash([16, 12]);
    ctx.lineDashOffset = -state.t*120;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, TAU);
    ctx.stroke();

    // outer danger haze
    ctx.setLineDash([]);
    ctx.lineWidth = 16;
    ctx.strokeStyle = `rgba(255,95,127,${0.12 + pulse*0.06})`;
    ctx.beginPath();
    ctx.arc(cx, cy, r+18, 0, TAU);
    ctx.stroke();
    ctx.restore();
  }

  function drawPlayer(){
    const inv = player.dashInvuln > 0 ? (0.35 + 0.65*Math.abs(Math.sin(state.t*22))) : 1;

    // body
    ctx.save();
    ctx.translate(player.x, player.y);

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.ellipse(0, player.r+7, player.r*1.1, player.r*0.6, 0, 0, TAU);
    ctx.fill();

    // core
    ctx.globalAlpha = inv;
    const grd = ctx.createRadialGradient(-4, -6, 2, 0, 0, player.r*1.5);
    grd.addColorStop(0, 'rgba(255,255,255,.95)');
    grd.addColorStop(0.2, 'rgba(122,166,255,.95)');
    grd.addColorStop(1, 'rgba(55,82,170,.95)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, player.r, 0, TAU);
    ctx.fill();

    // face direction
    ctx.rotate(player.facing);
    ctx.strokeStyle = 'rgba(0,0,0,.55)';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(4, 0);
    ctx.lineTo(player.r + 8, 0);
    ctx.stroke();

    ctx.restore();

    // HP bar above
    const w = 120;
    const x = player.x - w/2;
    const y = player.y - player.r - 26;
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    roundRect(x, y, w, 10, 6); ctx.fill();
    const pct = clamp(player.hp/100, 0, 1);
    const col = pct > 0.5 ? 'rgba(109,255,176,.92)' : (pct > 0.25 ? 'rgba(255,211,109,.92)' : 'rgba(255,95,127,.92)');
    ctx.fillStyle = col;
    roundRect(x+1.5, y+1.5, (w-3)*pct, 7, 5); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.14)';
    ctx.strokeRect(x, y, w, 10);
    ctx.restore();
  }

  function drawTrail(){
    if (!player.trail.length) return;
    ctx.save();
    for (const t of player.trail){
      const a = clamp(t.life/0.25, 0, 1);
      ctx.globalAlpha = a*0.28;
      ctx.fillStyle = 'rgba(122,166,255,1)';
      ctx.beginPath();
      ctx.arc(t.x, t.y, player.r*0.85, 0, TAU);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawBot(b){
    ctx.save();
    ctx.translate(b.x, b.y);

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.ellipse(0, b.r+7, b.r*1.1, b.r*0.62, 0, 0, TAU);
    ctx.fill();

    // body
    ctx.globalAlpha = 1;
    const hurt = b.hitFlash;
    const base = `rgba(255,95,127,${0.88})`;
    const alt = `rgba(255,211,109,${0.9})`;
    const grd = ctx.createRadialGradient(-4, -6, 2, 0, 0, b.r*1.5);
    grd.addColorStop(0, 'rgba(255,255,255,.92)');
    grd.addColorStop(0.25, hurt>0 ? alt : base);
    grd.addColorStop(1, 'rgba(120,28,54,.95)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, b.r, 0, TAU);
    ctx.fill();

    // eye
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.beginPath();
    ctx.arc(5, -2, 3.1, 0, TAU);
    ctx.fill();

    ctx.restore();

    // hp bar
    const w = 64;
    const x = b.x - w/2;
    const y = b.y - b.r - 18;
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    roundRect(x, y, w, 8, 6); ctx.fill();
    const pct = clamp(b.hp/b.maxHp, 0, 1);
    ctx.fillStyle = 'rgba(255,211,109,.9)';
    roundRect(x+1.5, y+1.5, (w-3)*pct, 5, 5); ctx.fill();
    ctx.restore();
  }

  function drawSwipe(){
    const arc = player.attackArc;
    const r1 = 38;
    const r2 = 90;
    const a0 = player.facing - arc;
    const a1 = player.facing + arc;
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.globalAlpha = 0.35;
    const grd = ctx.createRadialGradient(0,0,r1,0,0,r2);
    grd.addColorStop(0, 'rgba(122,166,255,.0)');
    grd.addColorStop(1, 'rgba(122,166,255,.55)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0,0,r2,a0,a1);
    ctx.arc(0,0,r1,a1,a0,true);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawParticles(){
    if (!particles.length) return;
    ctx.save();
    for (const p of particles){
      const a = clamp(p.life/0.7, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = `hsla(${p.hue}, 95%, 65%, 0.9)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, TAU);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawFloatingText(){
    if (!state.floatingText.length) return;
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = '800 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    for (const ft of state.floatingText){
      const a = clamp(ft.life/0.9, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = ft.color;
      ctx.fillText(ft.text, ft.x, ft.y);
    }
    ctx.restore();
  }

  function drawOverlay(){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.fillRect(0,0,W,H);

    // panel
    const pw = 640;
    const ph = 340;
    const px = (W - pw)/2;
    const py = (H - ph)/2;
    ctx.fillStyle = 'rgba(18,20,74,.88)';
    roundRect(px, py, pw, ph, 20);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.16)';
    ctx.lineWidth = 2;
    roundRect(px, py, pw, ph, 20);
    ctx.stroke();

    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(233,236,255,.98)';
    ctx.font = '900 44px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';

    let headline = 'Strongest Battlegrounds';
    let sub = 'Remix';
    if (state.mode === 'win') { headline = 'Victory!'; sub = 'You hit the score goal.'; }
    if (state.mode === 'lose') { headline = 'Defeat'; sub = (player.hp<=0) ? 'You got KO\'d.' : 'Time\'s up.'; }

    ctx.fillText(headline, W/2, py + 86);

    ctx.font = '750 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(170,176,255,.95)';
    ctx.fillText(sub, W/2, py + 122);

    ctx.fillStyle = 'rgba(233,236,255,.95)';
    ctx.font = '800 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';

    if (state.mode === 'title'){
      ctx.fillText('Stay inside the Storm Ring. Build Focus. Spend it for a Burst.', W/2, py + 170);
      ctx.fillText('Reach 1200 score in 90 seconds.', W/2, py + 196);
      ctx.fillStyle = 'rgba(122,166,255,.95)';
      ctx.font = '900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Press Enter to Start', W/2, py + 246);
    } else {
      ctx.fillText('Score: ' + Math.floor(state.score), W/2, py + 172);
      ctx.fillText('Combo: x' + Math.round(state.combo), W/2, py + 196);
      ctx.fillStyle = 'rgba(122,166,255,.95)';
      ctx.font = '900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Press Enter to Restart', W/2, py + 246);
    }

    ctx.fillStyle = 'rgba(170,176,255,.9)';
    ctx.font = '650 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Inspired by The Strongest Battlegrounds (note only; no affiliation)', W/2, py + ph - 34);

    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // ---------- buttons ----------
  ui.btnStart.addEventListener('click', () => startGame());
  ui.btnRestart.addEventListener('click', () => startGame());
  ui.btnMute.addEventListener('click', () => {
    audioOn = !audioOn;
    ui.btnMute.textContent = 'Sound: ' + (audioOn ? 'On' : 'Off');
    if (audioOn) beep('sine', 520, 0.05, 0.05);
  });

  // ensure audio allowed after first gesture (mobile)
  window.addEventListener('pointerdown', () => ensureAudio(), {once:true});

  // ---------- init ----------
  reset();
  setMode('title');
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
