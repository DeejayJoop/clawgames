<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HyperRacer (Model + Faster + Backward Road)</title>
  <style>
    :root{--fg:#eef2ff;--muted:#c7c8ff;--bg:#070b14}
    html,body{height:100%;margin:0;overflow:hidden;background:radial-gradient(1200px 900px at 50% 20%, #1a2a55, var(--bg) 65%);
      color:var(--fg);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header,footer{position:fixed;left:0;right:0;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;
      background:linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,0));border-bottom:1px solid rgba(255,255,255,.10)}
    footer{top:auto;bottom:0;border-bottom:none;border-top:1px solid rgba(255,255,255,.10);
      background:linear-gradient(to top, rgba(255,255,255,.08), rgba(255,255,255,0));color:var(--muted)}
    h1{margin:0;font-size:14px;letter-spacing:.12em;text-transform:uppercase}
    .sub{color:var(--muted);font-size:12px}
    .right{display:flex;gap:10px;align-items:center}
    .pill{border:1px solid rgba(255,255,255,.18);background:rgba(0,0,0,.22);backdrop-filter: blur(6px);
      border-radius:999px;padding:6px 10px;display:flex;gap:10px;align-items:center}
    .pill b{font-variant-numeric:tabular-nums}

    #panelWrap{position:fixed;inset:48px 0 46px 0;display:grid;place-items:center;pointer-events:none}
    .panel{pointer-events:auto;width:min(760px, calc(100% - 28px));border-radius:16px;border:1px solid rgba(255,255,255,.16);
      background:linear-gradient(180deg, rgba(0,0,0,.48), rgba(0,0,0,.22));box-shadow:0 30px 90px rgba(0,0,0,.55);
      backdrop-filter: blur(10px);padding:16px 16px 14px}
    .panel h2{margin:0 0 6px;font-size:14px;letter-spacing:.12em;text-transform:uppercase}
    .panel p{margin:0 0 12px;color:var(--muted)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    button{appearance:none;border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));color:var(--fg);
      border-radius:12px;padding:10px 12px;cursor:pointer;font-weight:750}
    button.secondary{background:rgba(0,0,0,.22);font-weight:650}
    button:active{transform:translateY(1px)}
    .hint{font-size:12px;color:rgba(232,236,255,.72)}
    kbd{font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;color:var(--fg);
      border:1px solid rgba(255,255,255,.22);background:rgba(0,0,0,.30);border-radius:6px;padding:2px 6px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>HyperRacer</h1>
      <div class="sub">ToyCar.glb model • faster • road/props move backwards</div>
    </div>
    <div class="right">
      <div class="pill"><span>Speed</span><b id="spd">0</b></div>
      <div class="pill"><span>Distance</span><b id="dist">0.0</b></div>
      <div class="pill"><span>Time</span><b id="time">0.0</b></div>
    </div>
  </header>

  <div id="panelWrap">
    <div class="panel" id="menu">
      <h2>Start</h2>
      <p>This version downloads a local 3D car model (<code>ToyCar.glb</code>) and uses module-based Three.js loaders.
      If your VM struggles, switch Quality to Low.</p>
      <div class="row">
        <button id="btnPlay">Drive</button>
        <button id="btnQuality" class="secondary">Quality: High</button>
      </div>
      <p class="hint">Controls: steer <kbd>A</kbd>/<kbd>D</kbd> or <kbd>←</kbd>/<kbd>→</kbd> • accelerate <kbd>W</kbd>/<kbd>↑</kbd> • brake <kbd>S</kbd>/<kbd>↓</kbd> • restart <kbd>R</kbd></p>
      <p class="hint">Files needed in same folder: <code>three.module.js</code>, <code>GLTFLoader.js</code>, <code>ToyCar.glb</code></p>
    </div>
  </div>

  <footer>
    <div>Steer <kbd>A</kbd>/<kbd>D</kbd> • Accelerate <kbd>W</kbd> • Brake <kbd>S</kbd> • Restart <kbd>R</kbd></div>
    <div id="status">Ready.</div>
  </footer>

  <script type="module">
    import * as THREE from './three.module.js';
    import { GLTFLoader } from './GLTFLoader.js';

    const ui = {
      spd: document.getElementById('spd'),
      dist: document.getElementById('dist'),
      time: document.getElementById('time'),
      status: document.getElementById('status'),
      menu: document.getElementById('menu'),
      btnPlay: document.getElementById('btnPlay'),
      btnQuality: document.getElementById('btnQuality')
    };

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;

    function hideMenu(){ ui.menu.style.display='none'; }

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setClearColor(0x000000, 0);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1020, 0.020);

    const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 500);

    // Sky
    const skyGeo = new THREE.SphereGeometry(300, 24, 16);
    skyGeo.scale(-1,1,1);
    const pos = skyGeo.attributes.position;
    const colors = [];
    const top = new THREE.Color(0x85b7ff);
    const mid = new THREE.Color(0x27407a);
    const bot = new THREE.Color(0x070b14);
    for(let i=0;i<pos.count;i++){
      const y = pos.getY(i);
      const t = clamp((y+300)/600, 0, 1);
      const c = new THREE.Color();
      if(t>0.55){ c.copy(mid).lerp(top, (t-0.55)/0.45); }
      else { c.copy(bot).lerp(mid, t/0.55); }
      colors.push(c.r,c.g,c.b);
    }
    skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    const sky = new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({ vertexColors:true }));
    scene.add(sky);

    scene.add(new THREE.HemisphereLight(0xbfdcff, 0x1a0f26, 0.35));

    const sun = new THREE.DirectionalLight(0xffffff, 3.8);
    sun.position.set(-10, 14, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 2;
    sun.shadow.camera.far = 90;
    sun.shadow.camera.left = -28;
    sun.shadow.camera.right = 28;
    sun.shadow.camera.top = 28;
    sun.shadow.camera.bottom = -28;
    scene.add(sun);

    const world = new THREE.Group();
    scene.add(world);

    // Procedural road texture
    function makeRoadTexture(){
      const cv = document.createElement('canvas');
      cv.width = 1024;
      cv.height = 1024;
      const g = cv.getContext('2d');
      g.fillStyle = '#1b1f2a';
      g.fillRect(0,0,cv.width,cv.height);
      const img = g.getImageData(0,0,cv.width,cv.height);
      const d = img.data;
      for(let i=0;i<d.length;i+=4){
        const n = (Math.random()*40)|0;
        d[i]+=n; d[i+1]+=n; d[i+2]+=n;
      }
      g.putImageData(img,0,0);
      g.strokeStyle = 'rgba(255,255,255,0.85)';
      g.lineWidth = 18;
      g.setLineDash([60, 48]);
      g.beginPath();
      g.moveTo(cv.width*0.5, 0);
      g.lineTo(cv.width*0.5, cv.height);
      g.stroke();
      g.setLineDash([]);
      g.strokeStyle = 'rgba(255,214,107,0.75)';
      g.lineWidth = 10;
      g.beginPath();
      g.moveTo(cv.width*0.12, 0); g.lineTo(cv.width*0.12, cv.height);
      g.moveTo(cv.width*0.88, 0); g.lineTo(cv.width*0.88, cv.height);
      g.stroke();
      const tex = new THREE.CanvasTexture(cv);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(1, 10);
      tex.anisotropy = 8;
      return tex;
    }

    const roadTex = makeRoadTexture();
    const roadMat = new THREE.MeshStandardMaterial({ map: roadTex, roughness: 0.92, metalness: 0.02 });
    const road = new THREE.Mesh(new THREE.PlaneGeometry(14, 240, 1, 1), roadMat);
    road.rotation.x = -Math.PI/2;
    road.receiveShadow = true;
    world.add(road);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 240), new THREE.MeshStandardMaterial({ color: 0x0a1720, roughness: 1.0 }));
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.02;
    ground.receiveShadow = true;
    world.add(ground);

    // Trees (simple instanced-ish group)
    const props = new THREE.Group();
    world.add(props);
    const treeMat = new THREE.MeshStandardMaterial({ color: 0x0b2a1a, roughness: 1.0 });
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3a2b1a, roughness: 1.0 });
    const trees=[];
    function addTree(x,z, s=1){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.22, 1.4, 8), trunkMat);
      trunk.position.y = 0.7; trunk.castShadow = true;
      const crown = new THREE.Mesh(new THREE.ConeGeometry(0.9, 2.2, 10), treeMat);
      crown.position.y = 2.1; crown.castShadow = true;
      g.add(trunk, crown);
      g.position.set(x,0,z);
      g.scale.setScalar(s);
      props.add(g);
      trees.push(g);
    }
    for(let i=0;i<70;i++){
      const side = i%2===0 ? -1 : 1;
      const x = side*(8 + Math.random()*18);
      const z = -10 - Math.random()*220;
      addTree(x,z, 0.9+Math.random()*0.8);
    }

    // Car (GLB)
    const car = new THREE.Group();
    world.add(car);
    let carModel = null;

    const loader = new GLTFLoader();
    loader.load('./ToyCar.glb', (gltf) => {
      carModel = gltf.scene;
      carModel.traverse((o)=>{
        if(o.isMesh){
          o.castShadow = true;
          o.receiveShadow = false;
          // Slightly more realistic material response
          if(o.material){
            o.material.roughness = Math.min(1, (o.material.roughness ?? 0.7) + 0.1);
            o.material.metalness = Math.min(1, (o.material.metalness ?? 0.1) + 0.1);
          }
        }
      });
      carModel.scale.setScalar(0.85);
      carModel.rotation.y = Math.PI; // face forward
      carModel.position.y = 0.0;
      car.add(carModel);
      ui.status.textContent = 'Car model loaded.';
    }, undefined, (err) => {
      console.error(err);
      ui.status.textContent = 'Failed to load ToyCar.glb (check file is next to HTML).';
    });

    const state = {
      running:false,
      quality:'high',
      t:0,
      last:performance.now(),
      speed:0,
      dist:0,
      x:0
    };

    const input = { left:false,right:false,up:false,down:false };
    addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if(['a','arrowleft'].includes(k)) input.left=true;
      if(['d','arrowright'].includes(k)) input.right=true;
      if(['w','arrowup'].includes(k)) input.up=true;
      if(['s','arrowdown'].includes(k)) input.down=true;
      if(k==='r') restart();
    });
    addEventListener('keyup', (e)=>{
      const k = e.key.toLowerCase();
      if(['a','arrowleft'].includes(k)) input.left=false;
      if(['d','arrowright'].includes(k)) input.right=false;
      if(['w','arrowup'].includes(k)) input.up=false;
      if(['s','arrowdown'].includes(k)) input.down=false;
    });

    function resize(){
      const w=innerWidth,h=innerHeight;
      camera.aspect=w/h;
      camera.updateProjectionMatrix();
      const dpr=devicePixelRatio||1;
      renderer.setPixelRatio(state.quality==='high'?Math.min(2,dpr):1);
      renderer.setSize(w,h,false);
    }
    addEventListener('resize', resize);

    function restart(){
      state.running=true;
      state.t=0;
      state.last=performance.now();
      state.speed=0;
      state.dist=0;
      state.x=0;
      car.position.set(0,0, 10);
      // Road moves backwards: scroll texture forward and pull props away (decreasing z)
      roadTex.offset.y = 0;
      for(const tr of trees){
        tr.position.z = -10 - Math.random()*220;
        const side = tr.position.x<0 ? -1 : 1;
        tr.position.x = side*(8 + Math.random()*18);
      }
      ui.status.textContent='Drive.';
      hideMenu();
    }

    ui.btnPlay.onclick = restart;
    ui.btnQuality.onclick = () => {
      state.quality = state.quality==='high' ? 'low' : 'high';
      ui.btnQuality.textContent = `Quality: ${state.quality==='high'?'High':'Low'}`;
      ui.status.textContent = state.quality==='high' ? 'High quality.' : 'Low quality.';
      resize();
    };

    camera.position.set(0, 4.2, 15.5);
    camera.lookAt(0, 1.0, 0);

    function tick(now){
      requestAnimationFrame(tick);
      if(!renderer.domElement.width) resize();

      if(!state.running){
        car.rotation.y = Math.sin(performance.now()*0.001)*0.04;
        renderer.render(scene, camera);
        return;
      }

      const dt = Math.min(0.033, (now-state.last)/1000);
      state.last=now;
      state.t += dt;

      // Faster settings
      const maxSpeed=95;
      const accel=55;
      const brake=75;
      const drag=6.0;

      if(input.up) state.speed += accel*dt;
      if(input.down) state.speed -= brake*dt;
      state.speed = lerp(state.speed, 0, drag*dt);
      state.speed = clamp(state.speed, 0, maxSpeed);

      const steer = (input.right?1:0) - (input.left?1:0);
      state.x += steer * (7.2 + state.speed*0.07) * dt;
      state.x = clamp(state.x, -4.6, 4.6);

      car.position.x = lerp(car.position.x, state.x, 6*dt);
      car.rotation.z = lerp(car.rotation.z, -steer*0.14, 6*dt);
      car.rotation.y = lerp(car.rotation.y, -steer*0.06, 4*dt);

      // road texture: scroll opposite direction for "road moves backwards" feel
      roadTex.offset.y += state.speed*dt*0.022;

      // move trees backwards (away from camera)
      const dz = state.speed*dt;
      state.dist += dz*0.065;
      ui.dist.textContent = state.dist.toFixed(1);
      ui.time.textContent = state.t.toFixed(1);
      ui.spd.textContent = String(Math.round(state.speed*3.6));

      for(const tr of trees){
        tr.position.z -= dz;
        if(tr.position.z < -260){
          tr.position.z = 18 + Math.random()*80;
          const side = tr.position.x<0 ? -1 : 1;
          tr.position.x = side*(8 + Math.random()*18);
        }
      }

      // camera follow + shake
      const shake = (state.speed/maxSpeed) * 0.12;
      camera.position.x = lerp(camera.position.x, car.position.x*0.25, 4.8*dt) + Math.sin(state.t*16)*shake;
      camera.position.y = lerp(camera.position.y, 4.2, 2.6*dt);
      camera.position.z = lerp(camera.position.z, 15.5, 2.6*dt);
      camera.lookAt(car.position.x*0.15, 1.0, car.position.z-8);

      renderer.render(scene, camera);
    }

    resize();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
