<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon Drift — Single‑File HTML Game</title>
  <style>
    :root{
      --bg0:#070814; --bg1:#0b1030; --fg:#e8ecff; --muted:#aab3ff;
      --neon:#7cf7ff; --pink:#ff4fd8; --gold:#ffd66b; --good:#31f2a3; --bad:#ff5666;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 900px at 50% 40%, var(--bg1), var(--bg0) 60%); color:var(--fg); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; overflow:hidden;}
    #wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto;}
    header{display:flex; align-items:center; justify-content:space-between; padding:10px 14px; background:linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,0)); border-bottom:1px solid rgba(255,255,255,.10)}
    header .title{display:flex; gap:10px; align-items:baseline}
    header h1{margin:0; font-size:14px; letter-spacing:.12em; text-transform:uppercase}
    header .sub{color:var(--muted); font-size:12px}
    header .right{display:flex; gap:10px; align-items:center}
    .pill{border:1px solid rgba(255,255,255,.18); background:rgba(0,0,0,.22); backdrop-filter: blur(6px);
      border-radius:999px; padding:6px 10px; display:flex; gap:10px; align-items:center;}
    .pill b{font-variant-numeric:tabular-nums}
    #game{position:relative;}
    canvas{display:block; width:100%; height:100%;}
    footer{padding:10px 14px; border-top:1px solid rgba(255,255,255,.10); background:linear-gradient(to top, rgba(255,255,255,.08), rgba(255,255,255,0)); display:flex; justify-content:space-between; align-items:center; gap:12px; color:var(--muted)}
    footer .keys{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
    kbd{font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; color:var(--fg);
      border:1px solid rgba(255,255,255,.22); border-bottom-color: rgba(255,255,255,.08);
      background:rgba(0,0,0,.30); border-radius:6px; padding:2px 6px;}

    #overlay{position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;}
    .panel{pointer-events:auto; width:min(520px, calc(100% - 28px)); border-radius:16px;
      border:1px solid rgba(255,255,255,.16);
      background:linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.20));
      box-shadow:0 30px 90px rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      padding:16px 16px 14px;}
    .panel h2{margin:0 0 6px; font-size:14px; letter-spacing:.12em; text-transform:uppercase}
    .panel p{margin:0 0 12px; color:var(--muted)}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    button{appearance:none; border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(180deg, rgba(124,247,255,.18), rgba(124,247,255,.06));
      color:var(--fg); border-radius:12px; padding:10px 12px; cursor:pointer; font-weight:650;
      box-shadow:0 10px 28px rgba(124,247,255,.08);}
    button.secondary{background:rgba(0,0,0,.22)}
    button:active{transform:translateY(1px)}
    .hint{font-size:12px; color:rgba(232,236,255,.72)}
    .small{font-size:12px; color:var(--muted)}

    /* accessibility */
    .sr{position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden}
  </style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="title">
      <h1>Neon Drift</h1>
      <div class="sub">single-file canvas arcade • survive the lane</div>
    </div>
    <div class="right">
      <div class="pill" title="Score">
        <span>Score</span><b id="score">0</b>
      </div>
      <div class="pill" title="Combo">
        <span>Combo</span><b id="combo">x1</b>
      </div>
      <div class="pill" title="Level">
        <span>Level</span><b id="level">1</b>
      </div>
    </div>
  </header>

  <div id="game">
    <canvas id="c"></canvas>
    <div id="overlay">
      <div class="panel" id="menu">
        <h2>Start</h2>
        <p>Slide left/right, collect <b style="color:var(--gold)">orbs</b>, avoid <b style="color:var(--bad)">shards</b>. Build combo by collecting consecutively.</p>
        <div class="row">
          <button id="btnPlay">Play</button>
          <button id="btnPractice" class="secondary">Practice</button>
          <button id="btnMute" class="secondary">Sound: On</button>
        </div>
        <p class="hint">Controls: <kbd>←</kbd>/<kbd>→</kbd> or <kbd>A</kbd>/<kbd>D</kbd> • <kbd>Space</kbd> dash • <kbd>P</kbd> pause</p>
        <p class="small">Tip: dash has a short cooldown. A perfect dash through a gap grants a brief <b style="color:var(--good)">shield</b>.</p>
      </div>

      <div class="panel" id="paused" style="display:none">
        <h2>Paused</h2>
        <p>Take a breath. The lane will wait.</p>
        <div class="row">
          <button id="btnResume">Resume</button>
          <button id="btnRestart" class="secondary">Restart</button>
        </div>
        <p class="hint">Press <kbd>P</kbd> to toggle pause.</p>
      </div>

      <div class="panel" id="gameover" style="display:none">
        <h2>Run Complete</h2>
        <p id="finalLine">You lasted <b>0</b> seconds.</p>
        <div class="row">
          <button id="btnAgain">Play again</button>
          <button id="btnShare" class="secondary">Copy score</button>
        </div>
        <p class="hint">Try: chain 10 orbs without a miss to unlock a secret colorway.</p>
      </div>
    </div>
    <div class="sr" aria-live="polite" id="aria"></div>
  </div>

  <footer>
    <div class="keys">
      <span>Move</span><kbd>←</kbd><kbd>→</kbd><span>Dash</span><kbd>Space</kbd><span>Pause</span><kbd>P</kbd><span>Restart</span><kbd>R</kbd>
    </div>
    <div id="status">Ready.</div>
  </footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    score: document.getElementById('score'),
    combo: document.getElementById('combo'),
    level: document.getElementById('level'),
    status: document.getElementById('status'),
    aria: document.getElementById('aria'),
    menu: document.getElementById('menu'),
    paused: document.getElementById('paused'),
    gameover: document.getElementById('gameover'),
    finalLine: document.getElementById('finalLine'),
    btnPlay: document.getElementById('btnPlay'),
    btnPractice: document.getElementById('btnPractice'),
    btnMute: document.getElementById('btnMute'),
    btnResume: document.getElementById('btnResume'),
    btnRestart: document.getElementById('btnRestart'),
    btnAgain: document.getElementById('btnAgain'),
    btnShare: document.getElementById('btnShare')
  };

  // ----- resize -----
  const DPR = () => Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize(){
    const r = canvas.parentElement.getBoundingClientRect();
    canvas.width = Math.floor(r.width * DPR());
    canvas.height = Math.floor(r.height * DPR());
  }
  window.addEventListener('resize', resize);

  // ----- tiny audio synth (no files) -----
  let audioOn = true;
  let actx = null;
  function ensureAudio(){
    if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function beep(type='sine', freq=440, dur=0.08, gain=0.05){
    if (!audioOn) return;
    ensureAudio();
    const t0 = actx.currentTime;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(actx.destination);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }
  function chord(freqs, dur=0.12, gain=0.03){
    freqs.forEach((f,i)=>beep(i%2?'triangle':'sine', f, dur, gain));
  }

  // ----- helpers -----
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);

  // ----- game state -----
  const state = {
    running:false,
    paused:false,
    practice:false,
    t:0,
    dt:0,
    last:0,
    score:0,
    combo:1,
    comboStreak:0,
    level:1,
    timeAlive:0,
    secret:false
  };

  // player in normalized lane coords
  const player = {
    x:0, // -1..1
    vx:0,
    y:0.78, // 0..1
    r:0.04,
    dash: {
      ready:true,
      cd:0,
      inv:0,
      shield:0
    },
    color:()=> state.secret ? '#ffd66b' : '#7cf7ff'
  };

  const input = { left:false, right:false, dash:false };

  // entities
  const shards = []; // obstacles
  const orbs = [];   // collectibles
  const particles = [];
  const trails = [];

  function spawnParticle(x,y, opts={}){
    particles.push({
      x,y,
      vx: opts.vx ?? rand(-0.15,0.15),
      vy: opts.vy ?? rand(-0.4,0.1),
      r: opts.r ?? rand(0.004,0.014),
      life: opts.life ?? rand(0.25,0.8),
      t:0,
      hue: opts.hue ?? rand(180, 320),
      a: opts.a ?? 1
    });
  }

  function spawnBurst(x,y, hue=195, n=18){
    for(let i=0;i<n;i++) spawnParticle(x,y,{vx:rand(-0.35,0.35), vy:rand(-0.55,0.15), r:rand(0.004,0.016), life:rand(0.25,0.95), hue});
  }

  function reset(runPractice=false){
    state.running = true;
    state.paused = false;
    state.practice = runPractice;
    state.t = 0; state.dt = 0; state.last = performance.now();
    state.score = 0; state.combo=1; state.comboStreak=0; state.level=1; state.timeAlive=0;

    player.x = 0; player.vx=0;
    player.dash.ready = true; player.dash.cd=0; player.dash.inv=0; player.dash.shield=0;

    shards.length=0; orbs.length=0; particles.length=0; trails.length=0;

    ui.score.textContent = '0';
    ui.combo.textContent = 'x1';
    ui.level.textContent = '1';
    ui.status.textContent = runPractice ? 'Practice: shards deal no damage.' : 'Go!';
    ui.aria.textContent = 'Game started.';

    hideAllPanels();
  }

  function hideAllPanels(){
    ui.menu.style.display='none';
    ui.paused.style.display='none';
    ui.gameover.style.display='none';
  }

  function showPanel(panel){
    hideAllPanels();
    panel.style.display='block';
  }

  function gameOver(){
    state.running = false;
    const seconds = Math.max(0, state.timeAlive).toFixed(1);
    ui.finalLine.innerHTML = `You lasted <b>${seconds}</b> seconds • score <b>${state.score}</b> • max combo <b>x${state.combo}</b>.`;
    ui.status.textContent = 'Run complete.';
    ui.aria.textContent = 'Game over.';
    showPanel(ui.gameover);
    chord([220, 196, 165], 0.22, 0.04);
  }

  // ----- spawning cadence -----
  let nextShard = 0;
  let nextOrb = 0;

  function levelParams(){
    const l = state.level;
    return {
      speed: 0.55 + l*0.08,
      shardRate: Math.max(0.35, 0.95 - l*0.05),
      orbRate: Math.max(0.45, 1.15 - l*0.04),
      laneW: 0.82
    };
  }

  function spawnShard(){
    const p = levelParams();
    const w = rand(0.10, 0.22);
    const gapBias = Math.sin(state.t*0.7)*0.15;
    const x = clamp(rand(-p.laneW, p.laneW) + gapBias, -p.laneW, p.laneW);
    shards.push({ x, y:-0.15, w, h:rand(0.06,0.10), speed:p.speed, spin:rand(-2.2,2.2), t:0 });
  }

  function spawnOrb(){
    const p = levelParams();
    const x = rand(-p.laneW, p.laneW);
    orbs.push({ x, y:-0.12, r:rand(0.028,0.038), speed:p.speed*0.95, bob:rand(0,Math.PI*2), t:0 });
  }

  // ----- collision -----
  function circleRectCollide(cx,cy,cr, rx,ry,rw,rh){
    const px = clamp(cx, rx-rw*0.5, rx+rw*0.5);
    const py = clamp(cy, ry-rh*0.5, ry+rh*0.5);
    const dx = cx-px, dy=cy-py;
    return (dx*dx+dy*dy) <= cr*cr;
  }

  // ----- input -----
  const key = (e,down) => {
    const k = e.key.toLowerCase();
    if(['arrowleft','a'].includes(k)) input.left = down;
    if(['arrowright','d'].includes(k)) input.right = down;
    if(k === ' '){ input.dash = down; if (down) e.preventDefault(); }
    if(down && k === 'p') togglePause();
    if(down && k === 'r') { if(state.running) reset(state.practice); else showPanel(ui.menu); }
  };
  window.addEventListener('keydown', e=>key(e,true));
  window.addEventListener('keyup', e=>key(e,false));

  // pointer/touch
  let pointerActive = false;
  canvas.addEventListener('pointerdown', (e)=>{ pointerActive=true; canvas.setPointerCapture(e.pointerId); resumeAudioGesture(); });
  canvas.addEventListener('pointerup', ()=>{ pointerActive=false; });
  canvas.addEventListener('pointermove', (e)=>{
    if(!pointerActive || !state.running || state.paused) return;
    const r = canvas.getBoundingClientRect();
    const nx = ((e.clientX - r.left) / r.width) * 2 - 1;
    player.x = clamp(nx, -1, 1);
  });
  canvas.addEventListener('dblclick', ()=>tryDash());

  function resumeAudioGesture(){
    if (!audioOn) return;
    ensureAudio();
    if (actx.state === 'suspended') actx.resume();
  }

  // ----- pause -----
  function togglePause(){
    if(!state.running) return;
    state.paused = !state.paused;
    if(state.paused){
      ui.status.textContent='Paused.';
      showPanel(ui.paused);
      beep('sine', 220, 0.06, 0.04);
    } else {
      hideAllPanels();
      ui.status.textContent='Back in the lane.';
      beep('sine', 440, 0.06, 0.04);
      state.last = performance.now();
    }
  }

  // ----- dash -----
  function tryDash(){
    if(!state.running || state.paused) return;
    if(!player.dash.ready) return;
    player.dash.ready = false;
    player.dash.cd = 0.9;
    player.dash.inv = 0.16;

    // impulse
    const dir = (input.right?1:0) - (input.left?1:0);
    player.vx += (dir===0 ? (Math.random()<0.5?-1:1) : dir) * 3.2;

    // trail
    for(let i=0;i<18;i++) trails.push({x:player.x, y:player.y, a:1, r:player.r*(0.9+Math.random()*0.6)});

    chord([660, 990], 0.08, 0.03);
  }

  // ----- UI actions -----
  ui.btnPlay.onclick = () => { resumeAudioGesture(); reset(false); };
  ui.btnPractice.onclick = () => { resumeAudioGesture(); reset(true); };
  ui.btnMute.onclick = () => {
    audioOn = !audioOn;
    ui.btnMute.textContent = `Sound: ${audioOn ? 'On' : 'Off'}`;
    ui.status.textContent = audioOn ? 'Sound enabled.' : 'Sound muted.';
    if(audioOn) { resumeAudioGesture(); beep('triangle', 520, 0.07, 0.04); }
  };
  ui.btnResume.onclick = () => togglePause();
  ui.btnRestart.onclick = () => reset(state.practice);
  ui.btnAgain.onclick = () => reset(false);
  ui.btnShare.onclick = async () => {
    const text = `Neon Drift score: ${state.score} (lvl ${state.level}) — combo x${state.combo}`;
    try{ await navigator.clipboard.writeText(text); ui.status.textContent='Copied to clipboard.'; }
    catch{ ui.status.textContent=text; }
    beep('sine', 740, 0.07, 0.035);
  };

  // ensure dash on space press
  setInterval(()=>{ if(input.dash) tryDash(); }, 20);

  // ----- main loop -----
  function step(now){
    requestAnimationFrame(step);
    if(!canvas.width) resize();

    const w = canvas.width, h = canvas.height;

    if(!state.running){
      render(w,h,0);
      return;
    }
    if(state.paused){
      render(w,h,0);
      return;
    }

    state.dt = Math.min(0.033, (now - state.last) / 1000);
    state.last = now;
    state.t += state.dt;
    state.timeAlive += state.dt;

    // level up every ~18s
    const targetLevel = 1 + Math.floor(state.timeAlive / 18);
    if(targetLevel !== state.level){
      state.level = targetLevel;
      ui.level.textContent = String(state.level);
      ui.status.textContent = `Level ${state.level}. Speed up.`;
      chord([392, 494, 587], 0.10, 0.025);
    }

    // dash cooldown
    if(!player.dash.ready){
      player.dash.cd -= state.dt;
      if(player.dash.cd <= 0){ player.dash.ready = true; ui.status.textContent = 'Dash ready.'; beep('triangle', 840, 0.05, 0.02); }
    }
    player.dash.inv = Math.max(0, player.dash.inv - state.dt);
    player.dash.shield = Math.max(0, player.dash.shield - state.dt);

    // movement
    const accel = 7.2;
    const drag = 7.8;
    const dir = (input.right?1:0) - (input.left?1:0);
    player.vx += dir * accel * state.dt;
    player.vx = lerp(player.vx, 0, drag*state.dt);
    player.x = clamp(player.x + player.vx*state.dt, -1, 1);

    // spawn
    const p = levelParams();
    nextShard -= state.dt;
    nextOrb -= state.dt;
    if(nextShard <= 0){ spawnShard(); nextShard = p.shardRate * rand(0.7,1.2); }
    if(nextOrb <= 0){ spawnOrb(); nextOrb = p.orbRate * rand(0.8,1.35); }

    // update entities
    for(const s of shards){ s.t += state.dt; s.y += s.speed*state.dt; }
    for(const o of orbs){ o.t += state.dt; o.y += o.speed*state.dt; }

    // collisions (in normalized space)
    const px = player.x;
    const py = player.y;

    // collect orbs
    for(let i=orbs.length-1;i>=0;i--){
      const o = orbs[i];
      const bob = Math.sin(o.bob + o.t*6)*0.012;
      const dx = (px - o.x);
      const dy = (py - (o.y + bob));
      if(dx*dx + dy*dy <= (player.r + o.r)* (player.r + o.r)){
        orbs.splice(i,1);
        state.score += 10 * state.combo;
        state.comboStreak += 1;
        if(state.comboStreak % 3 === 0) state.combo += 1;
        ui.score.textContent = String(state.score);
        ui.combo.textContent = `x${state.combo}`;

        spawnBurst(o.x, o.y, 48 + state.combo*12, 22);
        beep('sine', 560 + state.combo*20, 0.05, 0.03);

        // secret unlock
        if(state.comboStreak >= 10) state.secret = true;
      }

      // miss breaks streak
      if(o.y > 1.2){
        orbs.splice(i,1);
        state.comboStreak = 0;
        state.combo = 1;
        ui.combo.textContent = 'x1';
      }
    }

    // hit shards
    for(let i=shards.length-1;i>=0;i--){
      const s = shards[i];
      const hit = circleRectCollide(px,py,player.r, s.x,s.y,s.w,s.h);
      if(hit){
        if(state.practice){
          shards.splice(i,1);
          spawnBurst(s.x,s.y, 0, 10);
          ui.status.textContent='Practice hit (no damage).';
          beep('square', 130, 0.05, 0.02);
          continue;
        }

        const inv = player.dash.inv > 0;
        const shield = player.dash.shield > 0;
        if(inv){
          shards.splice(i,1);
          // perfect dash gives shield
          player.dash.shield = 0.65;
          spawnBurst(s.x,s.y, 170, 26);
          chord([880, 1175], 0.08, 0.03);
          ui.status.textContent='Perfect dash! Shield online.';
        } else if(shield){
          shards.splice(i,1);
          player.dash.shield = Math.max(0, player.dash.shield - 0.35);
          spawnBurst(s.x,s.y, 160, 14);
          beep('triangle', 320, 0.06, 0.03);
          ui.status.textContent='Shield absorbed a hit.';
        } else {
          // death
          spawnBurst(px,py, 330, 40);
          gameOver();
          return;
        }
      }

      if(s.y > 1.25) shards.splice(i,1);
    }

    // particles
    for(let i=particles.length-1;i>=0;i--){
      const p0 = particles[i];
      p0.t += state.dt;
      p0.x += p0.vx*state.dt;
      p0.y += p0.vy*state.dt;
      p0.vy += 0.55*state.dt;
      if(p0.t >= p0.life) particles.splice(i,1);
    }

    // trails
    for(let i=trails.length-1;i>=0;i--){
      const tr = trails[i];
      tr.a -= state.dt*3.0;
      tr.r *= (1 + state.dt*2.2);
      if(tr.a <= 0) trails.splice(i,1);
    }

    render(w,h,state.dt);
  }

  function toScreen(nx, ny, w, h){
    // lane coords nx:-1..1, ny:0..1.2 -> pixels
    const cx = w*0.5;
    const laneHalf = Math.min(w,h)*0.40;
    const x = cx + nx*laneHalf;
    const y = ny*h;
    return [x,y,laneHalf];
  }

  function render(w,h,dt){
    const time = state.t;

    // background
    ctx.clearRect(0,0,w,h);

    // subtle moving nebula
    const g = ctx.createRadialGradient(w*0.5 + Math.sin(time*0.2)*w*0.08, h*0.35 + Math.cos(time*0.25)*h*0.06, 10, w*0.5, h*0.5, Math.max(w,h)*0.75);
    g.addColorStop(0, 'rgba(124,247,255,0.08)');
    g.addColorStop(0.5, 'rgba(255,79,216,0.05)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // lane
    const laneHalf = Math.min(w,h)*0.40;
    const cx = w*0.5;
    const left = cx - laneHalf;
    const right = cx + laneHalf;

    // lane glow edges
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = 'rgba(124,247,255,0.22)';
    ctx.lineWidth = Math.max(1, 2*DPR());
    ctx.beginPath(); ctx.moveTo(left, 0); ctx.lineTo(left, h);
    ctx.moveTo(right,0); ctx.lineTo(right,h);
    ctx.stroke();
    ctx.restore();

    // center dashes
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,0.30)';
    ctx.lineWidth = Math.max(1, 2*DPR());
    ctx.setLineDash([10*DPR(), 18*DPR()]);
    ctx.lineDashOffset = -time*90;
    ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,h);
    ctx.stroke();
    ctx.restore();

    // trails
    for(const tr of trails){
      const [x,y] = toScreen(tr.x,tr.y,w,h);
      ctx.beginPath();
      ctx.globalAlpha = Math.max(0, tr.a) * 0.65;
      ctx.fillStyle = 'rgba(124,247,255,1)';
      ctx.arc(x,y, tr.r*laneHalf, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // orbs
    for(const o of orbs){
      const bob = Math.sin(o.bob + o.t*6)*0.012;
      const [x,y] = toScreen(o.x, o.y + bob, w,h);
      const r = o.r*laneHalf;
      const glow = ctx.createRadialGradient(x,y, r*0.1, x,y, r*2.0);
      glow.addColorStop(0, 'rgba(255,214,107,0.95)');
      glow.addColorStop(0.45,'rgba(255,214,107,0.25)');
      glow.addColorStop(1,'rgba(255,214,107,0)');
      ctx.fillStyle = glow;
      ctx.beginPath(); ctx.arc(x,y, r*2.0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = 'rgba(255,214,107,0.95)';
      ctx.beginPath(); ctx.arc(x,y, r,0,Math.PI*2); ctx.fill();
    }

    // shards
    for(const s of shards){
      const [x,y] = toScreen(s.x, s.y, w,h);
      const rw = s.w*laneHalf;
      const rh = s.h*h;
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(Math.sin(s.t*1.3)*0.18 + s.spin*0.12);

      const grad = ctx.createLinearGradient(-rw, -rh, rw, rh);
      grad.addColorStop(0, 'rgba(255,86,102,0.15)');
      grad.addColorStop(0.5,'rgba(255,86,102,0.75)');
      grad.addColorStop(1, 'rgba(124,247,255,0.12)');

      ctx.fillStyle = grad;
      ctx.strokeStyle = 'rgba(255,86,102,0.55)';
      ctx.lineWidth = Math.max(1, 2*DPR());

      roundedRect(ctx, -rw/2, -rh/2, rw, rh, Math.min(rw,rh)*0.25);
      ctx.fill();
      ctx.globalAlpha = 0.6;
      ctx.stroke();
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // player
    {
      const [x,y] = toScreen(player.x, player.y, w,h);
      const r = player.r*laneHalf;

      // shield ring
      if(player.dash.shield > 0){
        ctx.save();
        ctx.globalAlpha = 0.25 + 0.25*Math.sin(time*10);
        ctx.strokeStyle = 'rgba(49,242,163,0.95)';
        ctx.lineWidth = Math.max(1, 3*DPR());
        ctx.beginPath(); ctx.arc(x,y, r*1.55, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }

      // inv flash
      const inv = player.dash.inv > 0;
      const base = player.color();
      const glow = ctx.createRadialGradient(x,y, r*0.2, x,y, r*2.4);
      glow.addColorStop(0, inv ? 'rgba(255,255,255,0.85)' : hexA(base,0.75));
      glow.addColorStop(0.4, hexA(base,0.18));
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath(); ctx.arc(x,y, r*2.4, 0, Math.PI*2); ctx.fill();

      ctx.fillStyle = inv ? 'rgba(255,255,255,0.92)' : hexA(base,0.95);
      ctx.beginPath(); ctx.arc(x,y, r, 0, Math.PI*2); ctx.fill();

      // nose
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.25, r*0.22, 0, Math.PI*2); ctx.fill();
    }

    // particles
    for(const p0 of particles){
      const [x,y] = toScreen(p0.x, p0.y, w,h);
      const t = p0.t / p0.life;
      const a = (1 - t) * p0.a;
      const r = p0.r*laneHalf;
      ctx.globalAlpha = a;
      ctx.fillStyle = `hsla(${p0.hue}, 95%, 65%, 1)`;
      ctx.beginPath(); ctx.arc(x,y, r, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // vignette
    ctx.save();
    const vg = ctx.createRadialGradient(cx, h*0.55, Math.min(w,h)*0.15, cx, h*0.55, Math.max(w,h)*0.75);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.55)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    // HUD hint while running
    if(state.running && !state.paused){
      // small dash bar
      const barW = 130*DPR(), barH = 6*DPR();
      const x = 14*DPR(), y = 14*DPR();
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      roundFill(x, y, barW, barH, 999);
      const pct = player.dash.ready ? 1 : clamp(1 - (player.dash.cd/0.9), 0, 1);
      ctx.fillStyle = player.dash.ready ? 'rgba(49,242,163,0.95)' : 'rgba(124,247,255,0.75)';
      roundFill(x, y, barW*pct, barH, 999);
      ctx.restore();
    }
  }

  function roundedRect(ctx, x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  function roundFill(x,y,w,h,r){
    ctx.beginPath();
    ctx.roundRect ? ctx.roundRect(x,y,w,h,r) : roundedRect(ctx,x,y,w,h,r);
    ctx.fill();
  }

  function hexA(hex, a){
    // #rrggbb -> rgba
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if(!m) return `rgba(255,255,255,${a})`;
    const r = parseInt(m[1],16), g = parseInt(m[2],16), b = parseInt(m[3],16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // start menu
  function init(){
    resize();
    showPanel(ui.menu);
    ui.status.textContent='Ready. Press Play.';
  }

  requestAnimationFrame(step);
  init();
})();
</script>
</body>
</html>
