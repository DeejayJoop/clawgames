<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horse Ride Platformer — Clawgames</title>
  <style>
    :root{--bg:#070518;--fg:#f4f6ff;--muted:#c7c8ff;--cyan:#67f5ff;--pink:#ff4fd8;--gold:#ffd66b;--good:#7dffcf;--bad:#ff5666;}
    html,body{height:100%;margin:0;overflow:hidden;background:radial-gradient(1200px 900px at 50% 30%, #21305b, #0a1020 55%, var(--bg) 100%);
      color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header,footer{padding:10px 14px;border-bottom:1px solid rgba(255,255,255,.10);
      background:linear-gradient(to bottom, rgba(255,255,255,.09), rgba(255,255,255,0))}
    footer{border-bottom:none;border-top:1px solid rgba(255,255,255,.10);
      background:linear-gradient(to top, rgba(255,255,255,.09), rgba(255,255,255,0));color:var(--muted)}
    h1{margin:0;font-size:14px;letter-spacing:.12em;text-transform:uppercase}
    .sub{margin-top:4px;color:var(--muted);font-size:12px}
    a{color:var(--cyan)}

    main{max-width:980px;margin:0 auto;padding:14px;display:grid;gap:12px;justify-items:center}
    .card{width:min(980px,100%);border:1px solid rgba(255,255,255,.16);border-radius:16px;background:rgba(0,0,0,.22);
      box-shadow:0 20px 60px rgba(0,0,0,.45);backdrop-filter: blur(10px);overflow:hidden}

    .bar{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.10)}
    .pill{border:1px solid rgba(255,255,255,.18);background:rgba(0,0,0,.22);border-radius:999px;padding:6px 10px;display:flex;gap:10px;align-items:center;color:var(--muted);font-size:12px}
    .pill b{color:var(--fg);font-variant-numeric:tabular-nums}

    .stage{display:grid;place-items:center;background:rgba(0,0,0,.18)}
    canvas{display:block;width:min(900px, 96vw);height:auto;aspect-ratio:16/9}

    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;padding:10px 12px;border-top:1px solid rgba(255,255,255,.10)}
    button{appearance:none;border:1px solid rgba(255,255,255,.18);background:linear-gradient(180deg, rgba(103,245,255,.20), rgba(103,245,255,.06));
      color:var(--fg);border-radius:12px;padding:10px 12px;cursor:pointer;font:inherit;font-weight:850;box-shadow:0 10px 28px rgba(103,245,255,.08)}
    button.secondary{background:rgba(0,0,0,.22);box-shadow:none;font-weight:650}
    button:active{transform:translateY(1px)}
    kbd{font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;color:var(--fg);
      border:1px solid rgba(255,255,255,.22);background:rgba(0,0,0,.30);border-radius:6px;padding:2px 6px}
  </style>
</head>
<body>
  <header>
    <h1>Horse Ride Platformer</h1>
    <div class="sub">Jump hurdles, collect carrots, don’t bonk. Back to <a href="./index.html">games shelf</a>.</div>
  </header>

  <main>
    <div class="card">
      <div class="bar">
        <div class="pill">Carrots <b id="carrots">0</b></div>
        <div class="pill">Distance <b id="dist">0</b>m</div>
        <div class="pill">Best <b id="best">0</b>m</div>
        <div class="pill" id="status">Ready.</div>
      </div>
      <div class="stage">
        <canvas id="c" width="960" height="540"></canvas>
      </div>
      <div class="controls">
        <button id="start">Start</button>
        <button id="restart" class="secondary">Restart</button>
        <span class="pill">Jump <kbd>Space</kbd>/<kbd>↑</kbd> • Duck <kbd>↓</kbd> • Dash <kbd>Shift</kbd></span>
      </div>
    </div>
  </main>

  <footer>
    Tip: Timing your dash through a hurdle gives a tiny speed boost.
  </footer>

<script>
(() => {
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');

  const ui = {
    carrots: document.getElementById('carrots'),
    dist: document.getElementById('dist'),
    best: document.getElementById('best'),
    status: document.getElementById('status'),
    start: document.getElementById('start'),
    restart: document.getElementById('restart'),
  };

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a,b)=>a+Math.random()*(b-a);

  const state = {
    running:false,
    t:0,
    last:performance.now(),
    dist:0,
    best:Number(localStorage.getItem('horse_best')||0),
    carrots:0,
    speed: 260, // px/sec base
    boost: 0,
  };
  ui.best.textContent = String(state.best);

  const groundY = 420;

  const rider = {
    x: 220,
    y: groundY,
    vy: 0,
    w: 86,
    h: 54,
    onGround:true,
    duck:false,
    dashCd: 0,
    dashT: 0,
    inv: 0,
  };

  const hurdles = []; // {x,w,h}
  const carrots = []; // {x,y}
  const clouds = Array.from({length:10}, (_,i)=>({x:rand(0,c.width),y:rand(40,180),s:rand(0.6,1.3)}));

  function reset(){
    state.running=false;
    state.t=0;
    state.last=performance.now();
    state.dist=0;
    state.carrots=0;
    state.speed=260;
    state.boost=0;

    rider.y=groundY;
    rider.vy=0;
    rider.onGround=true;
    rider.duck=false;
    rider.dashCd=0;
    rider.dashT=0;
    rider.inv=0;

    hurdles.length=0;
    carrots.length=0;

    ui.carrots.textContent='0';
    ui.dist.textContent='0';
    ui.status.textContent='Ready.';
  }

  function start(){
    if(state.running) return;
    state.running=true;
    ui.status.textContent='Ride!';
    state.last=performance.now();
  }

  function gameOver(){
    state.running=false;
    state.best = Math.max(state.best, Math.floor(state.dist));
    localStorage.setItem('horse_best', String(state.best));
    ui.best.textContent = String(state.best);
    ui.status.textContent='Game over. Restart?';
  }

  function spawnHurdle(){
    const h = rand(34, 68);
    hurdles.push({ x: c.width + 40, w: rand(22, 36), h });
  }

  function spawnCarrot(){
    const y = groundY - rand(60, 140);
    carrots.push({ x: c.width + 40, y });
  }

  let nextH = 0.9;
  let nextC = 0.7;

  function tick(now){
    requestAnimationFrame(tick);

    const dt = Math.min(0.033, (now - state.last)/1000);
    state.last = now;

    // animate even when not running
    state.t += dt;

    if(state.running){
      // difficulty scaling
      state.speed = 260 + Math.min(220, state.dist*1.2);
      state.boost = Math.max(0, state.boost - dt*0.8);

      // physics
      const g = 1800;
      rider.vy += g*dt;
      rider.y += rider.vy*dt;
      if(rider.y >= groundY){
        rider.y = groundY;
        rider.vy = 0;
        rider.onGround = true;
      } else {
        rider.onGround = false;
      }

      rider.dashCd = Math.max(0, rider.dashCd - dt);
      rider.dashT = Math.max(0, rider.dashT - dt);
      rider.inv = Math.max(0, rider.inv - dt);

      // scroll
      const v = (state.speed * (1 + state.boost)) * dt;
      state.dist += v/140; // px -> meters-ish
      ui.dist.textContent = String(Math.floor(state.dist));

      // spawn
      nextH -= dt;
      nextC -= dt;
      if(nextH <= 0){
        spawnHurdle();
        nextH = rand(0.8, 1.25) * Math.max(0.55, 1.0 - state.dist/800);
      }
      if(nextC <= 0){
        spawnCarrot();
        nextC = rand(0.55, 1.1);
      }

      // update hurdles
      for(let i=hurdles.length-1;i>=0;i--){
        const h = hurdles[i];
        h.x -= v;
        if(h.x < -80) hurdles.splice(i,1);
      }

      // update carrots
      for(let i=carrots.length-1;i>=0;i--){
        const cr = carrots[i];
        cr.x -= v;
        if(cr.x < -80) carrots.splice(i,1);
      }

      // collisions
      const px = rider.x;
      const py = rider.y;
      const ph = rider.duck ? rider.h*0.65 : rider.h;
      const pw = rider.w;
      const pTop = py - ph;
      const pLeft = px - pw/2;
      const pRight = px + pw/2;
      const pBottom = py;

      // carrots pickup
      for(let i=carrots.length-1;i>=0;i--){
        const cr = carrots[i];
        const dx = cr.x - px;
        const dy = cr.y - (py - ph*0.6);
        if(dx*dx + dy*dy < 26*26){
          carrots.splice(i,1);
          state.carrots += 1;
          ui.carrots.textContent = String(state.carrots);
        }
      }

      // hurdle hit
      if(rider.inv <= 0){
        for(const h of hurdles){
          const hx1 = h.x - h.w/2;
          const hx2 = h.x + h.w/2;
          const hy1 = groundY - h.h;
          const hy2 = groundY;
          const hit = (pLeft < hx2 && pRight > hx1 && pTop < hy2 && pBottom > hy1);
          if(hit){
            // if dashing: pass through and boost
            if(rider.dashT > 0){
              state.boost = Math.min(0.45, state.boost + 0.12);
              rider.inv = 0.18;
            } else {
              gameOver();
            }
            break;
          }
        }
      }

      // clouds
      for(const cl of clouds){
        cl.x -= v * 0.18 * cl.s;
        if(cl.x < -120){ cl.x = c.width + 120; cl.y = rand(40,180); cl.s = rand(0.6,1.3); }
      }
    } else {
      // idle clouds
      for(const cl of clouds){
        cl.x -= dt * 18 * cl.s;
        if(cl.x < -120){ cl.x = c.width + 120; }
      }
    }

    draw();
  }

  function draw(){
    ctx.clearRect(0,0,c.width,c.height);

    // sky
    const sky = ctx.createLinearGradient(0,0,0,c.height);
    sky.addColorStop(0,'#1e3a8a');
    sky.addColorStop(0.45,'#0b1020');
    sky.addColorStop(1,'#070518');
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,c.width,c.height);

    // stars
    ctx.globalAlpha = 0.25;
    for(let i=0;i<70;i++){
      const x = (i*97)%c.width;
      const y = ((i*193)%(220));
      ctx.fillStyle='white';
      ctx.fillRect(x,y,1.2,1.2);
    }
    ctx.globalAlpha = 1;

    // clouds
    for(const cl of clouds) drawCloud(cl.x, cl.y, 34*cl.s);

    // ground
    ctx.fillStyle='rgba(15,30,22,1)';
    ctx.fillRect(0, groundY, c.width, c.height-groundY);

    // grass glow
    const g = ctx.createLinearGradient(0,groundY,0,groundY+120);
    g.addColorStop(0,'rgba(125,255,207,0.10)');
    g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,groundY-10,c.width,140);

    // track lines
    ctx.globalAlpha=0.25;
    ctx.strokeStyle='rgba(255,255,255,0.35)';
    ctx.lineWidth=2;
    ctx.setLineDash([14,18]);
    ctx.lineDashOffset = -state.t*180;
    ctx.beginPath();
    ctx.moveTo(0, groundY+42);
    ctx.lineTo(c.width, groundY+42);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.globalAlpha=1;

    // carrots
    for(const cr of carrots) drawCarrot(cr.x, cr.y);

    // hurdles
    for(const h of hurdles) drawHurdle(h.x, groundY, h.w, h.h);

    // rider + horse
    drawHorse(rider.x, rider.y, rider.duck, rider.dashT>0, rider.inv>0);

    // vignette
    const vg = ctx.createRadialGradient(c.width*0.5,c.height*0.55, c.width*0.2, c.width*0.5,c.height*0.55, c.width*0.85);
    vg.addColorStop(0,'rgba(0,0,0,0)');
    vg.addColorStop(1,'rgba(0,0,0,0.55)');
    ctx.fillStyle=vg;
    ctx.fillRect(0,0,c.width,c.height);
  }

  function drawCloud(x,y,r){
    ctx.save();
    ctx.globalAlpha=0.35;
    ctx.fillStyle='rgba(255,255,255,1)';
    ctx.beginPath();
    ctx.arc(x, y, r*0.7, 0, Math.PI*2);
    ctx.arc(x+r*0.8, y+4, r*0.55, 0, Math.PI*2);
    ctx.arc(x-r*0.8, y+10, r*0.5, 0, Math.PI*2);
    ctx.arc(x+ r*0.1, y+14, r*0.65, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha=1;
  }

  function drawHurdle(x, baseY, w, h){
    const y = baseY - h;
    ctx.save();
    ctx.fillStyle='rgba(255,86,102,0.75)';
    roundRect(x-w/2, y, w, h, 10);
    ctx.fill();
    ctx.globalAlpha=0.35;
    ctx.fillStyle='rgba(255,255,255,1)';
    roundRect(x-w/2+4, y+6, w-8, h*0.22, 8);
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha=1;
  }

  function drawCarrot(x,y){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(Math.sin(state.t*3 + x*0.01)*0.15);
    // leaves
    ctx.fillStyle='rgba(125,255,207,0.85)';
    ctx.beginPath();
    ctx.moveTo(0,-12);
    ctx.quadraticCurveTo(-10,-18,-8,-30);
    ctx.quadraticCurveTo(-2,-20,0,-12);
    ctx.quadraticCurveTo(6,-18,8,-30);
    ctx.quadraticCurveTo(10,-18,0,-12);
    ctx.fill();
    // body
    ctx.fillStyle='rgba(255,214,107,0.95)';
    ctx.beginPath();
    ctx.moveTo(0,-8);
    ctx.lineTo(10,14);
    ctx.lineTo(0,26);
    ctx.lineTo(-10,14);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha=0.25;
    ctx.fillStyle='white';
    ctx.beginPath();
    ctx.moveTo(-2,-4);
    ctx.lineTo(3,12);
    ctx.lineTo(-2,20);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha=1;
  }

  function drawHorse(x,y,duck,dashing,inv){
    ctx.save();
    ctx.translate(x, y);

    const bob = state.running ? Math.sin(state.t*10) * (duck?1.5:2.5) : 0;
    ctx.translate(0, bob);

    const bodyW = 88;
    const bodyH = duck ? 34 : 44;

    // dash glow
    if(dashing){
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = 'rgba(103,245,255,1)';
      ctx.beginPath(); ctx.ellipse(-8, -bodyH*0.2, 78, 44, 0, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    // horse body
    ctx.fillStyle = inv ? 'rgba(255,255,255,0.9)' : 'rgba(168,113,72,0.95)';
    roundRect(-bodyW/2, -bodyH, bodyW, bodyH, 18);
    ctx.fill();

    // neck + head
    ctx.save();
    ctx.translate(bodyW*0.35, -bodyH*0.55);
    ctx.rotate(duck ? 0.12 : -0.08);
    ctx.fillStyle = inv ? 'rgba(255,255,255,0.9)' : 'rgba(168,113,72,0.95)';
    roundRect(-6, -26, 18, 30, 10);
    ctx.fill();
    roundRect(6, -26, 26, 18, 10);
    ctx.fill();
    // eye
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.beginPath(); ctx.arc(25, -17, 2.8, 0, Math.PI*2); ctx.fill();
    // ear
    ctx.globalAlpha=0.75;
    ctx.fillStyle='rgba(255,214,107,0.55)';
    ctx.beginPath();
    ctx.moveTo(8, -26);
    ctx.lineTo(2, -40);
    ctx.lineTo(14, -30);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha=1;

    // legs
    ctx.fillStyle='rgba(80,55,35,0.95)';
    const stride = state.running ? Math.sin(state.t*12) : 0;
    const legY = 0;
    for(const s of [-1,1]){
      roundRect(-24*s - 6, -legY, 12, 44, 8);
      ctx.fill();
      roundRect(10*s - 6, -legY + stride*8*s, 12, 44, 8);
      ctx.fill();
    }

    // rider
    ctx.save();
    ctx.translate(-10, -bodyH - 16);
    // torso
    ctx.fillStyle='rgba(255,79,216,0.80)';
    roundRect(-10, -18, 20, 22, 10);
    ctx.fill();
    // head
    ctx.fillStyle='rgba(255,255,255,0.88)';
    ctx.beginPath(); ctx.arc(0, -26, 10, 0, Math.PI*2); ctx.fill();
    // scarf
    ctx.globalAlpha=0.55;
    ctx.fillStyle='rgba(103,245,255,1)';
    roundRect(-18, -18, 36, 8, 6);
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha=1;

    // tail
    ctx.globalAlpha=0.8;
    ctx.strokeStyle='rgba(255,214,107,0.55)';
    ctx.lineWidth=6;
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.moveTo(-bodyW/2, -bodyH*0.55);
    ctx.quadraticCurveTo(-bodyW/2-25, -bodyH*0.20, -bodyW/2-18, 18);
    ctx.stroke();
    ctx.restore();
    ctx.globalAlpha=1;
  }

  function roundRect(x,y,w,h,r){
    r=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  // input
  function jump(){
    if(!state.running) return;
    if(rider.onGround){
      rider.vy = -760;
      rider.onGround = false;
    }
  }
  function dash(){
    if(!state.running) return;
    if(rider.dashCd<=0){
      rider.dashCd = 1.0;
      rider.dashT = 0.22;
      rider.inv = 0.22;
      state.boost = Math.min(0.45, state.boost + 0.08);
    }
  }

  addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if(k===' ' || k==='arrowup' || k==='w'){ e.preventDefault(); jump(); }
    if(k==='arrowdown' || k==='s'){ rider.duck = true; }
    if(k==='shift'){ dash(); }
    if(k==='r'){ reset(); start(); }
  });
  addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    if(k==='arrowdown' || k==='s'){ rider.duck = false; }
  });

  // touch
  c.addEventListener('pointerdown', (e) => {
    // left half jump, right half dash
    const r = c.getBoundingClientRect();
    const x = (e.clientX - r.left)/r.width;
    if(!state.running) start();
    if(x < 0.55) jump(); else dash();
  });

  ui.start.onclick = start;
  ui.restart.onclick = () => { reset(); start(); };

  reset();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
